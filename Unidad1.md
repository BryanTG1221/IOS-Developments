# Instituto Tecnológico de Nuevo Laredo
![Logo](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTbNxTFTT1xeBVwWk_S5h05KjoJreNJ4mO7E-S0BuxrdQ&s)


*Con la Ciencia por la Humanidad*

#### Ingenieria en sistemas computacionales
![ISC](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSt-jPzL5cckCBILZ_CEhfL5RxSHAG7z3AYslJWJya6KBqkkznDbzRchSDLoDab4SxQYr8&usqp=CAU)

### Materia: Desarrollo IOS
### Maestro: Humberto Peña

#### Presentado por:
- Bryan Azael Turrubiates Galindo (Número de Control: 19100793)


<br>
<br>
<br>
<br>
<br>
<br>
<br>


## Desarrollo iOS

El desarrollo iOS se refiere al proceso de creación de aplicaciones móviles para dispositivos que utilizan el sistema operativo iOS, desarrollado por Apple. iOS es conocido por ser el sistema operativo que impulsa los dispositivos móviles populares de Apple, como el iPhone y el iPad. A continuación, te proporciono una explicación general sobre el desarrollo iOS:

1. **Entorno de Desarrollo**:
   - Para desarrollar aplicaciones iOS, los desarrolladores utilizan principalmente el entorno de desarrollo integrado (IDE) de Apple llamado Xcode. Xcode proporciona las herramientas necesarias para escribir, depurar y diseñar aplicaciones iOS.

2. **Lenguaje de Programación**:
   - El lenguaje de programación principal para el desarrollo de aplicaciones iOS es Swift. Anteriormente, se usaba Objective-C, pero Swift se ha convertido en el lenguaje preferido debido a su legibilidad y eficiencia. Los desarrolladores también pueden usar Objective-C si trabajan en proyectos heredados.

3. **Diseño de Interfaz de Usuario**:
   - El diseño de la interfaz de usuario es un aspecto crítico del desarrollo iOS. Apple proporciona una plataforma llamada UIKit para diseñar interfaces de usuario atractivas y funcionales. Los desarrolladores pueden usar Storyboards y XIBs para crear interfaces gráficas de manera visual.

4. **APIs y Frameworks**:
   - iOS ofrece una amplia gama de APIs (Interfaces de Programación de Aplicaciones) y frameworks que permiten a los desarrolladores aprovechar características y funcionalidades específicas del dispositivo, como cámaras, sensores de movimiento, geolocalización y más. Por ejemplo, Core Location se utiliza para acceder a la ubicación del dispositivo, mientras que Core Data se utiliza para la gestión de bases de datos locales.

5. **Distribución de Aplicaciones**:
   - Para que las aplicaciones iOS estén disponibles para los usuarios, deben ser distribuidas a través de la App Store de Apple. Los desarrolladores deben seguir las pautas y directrices de Apple para que sus aplicaciones sean aprobadas y publicadas en la tienda.

6. **Actualizaciones y Mantenimiento**:
   - El desarrollo iOS no se detiene después de que una aplicación se publique en la App Store. Los desarrolladores deben seguir actualizando y manteniendo sus aplicaciones para garantizar su funcionamiento correcto en las versiones más recientes de iOS y para abordar problemas y agregar nuevas características.

7. **Pruebas y Depuración**:
   - Antes de lanzar una aplicación, los desarrolladores realizan pruebas exhaustivas en una variedad de dispositivos iOS para garantizar su funcionamiento correcto. Además, Xcode proporciona herramientas de depuración para identificar y solucionar problemas de programación.

8. **Seguridad**:
   - La seguridad es un aspecto fundamental del desarrollo iOS. Los desarrolladores deben seguir las mejores prácticas de seguridad para proteger los datos de los usuarios y garantizar que las aplicaciones no sean vulnerables a amenazas como el robo de datos o el malware.

9. **Compatibilidad de Dispositivos**:
   - Los desarrolladores deben considerar la compatibilidad con diferentes modelos de iPhone e iPad, teniendo en cuenta las diferencias de tamaño de pantalla y capacidad de procesamiento.

10. **Experiencia del Usuario**:
    - El objetivo final del desarrollo iOS es crear aplicaciones que ofrezcan una experiencia del usuario excepcional, con un diseño intuitivo, alto rendimiento y funciones útiles.

El desarrollo iOS es un campo dinámico que evoluciona constantemente con cada nueva versión de iOS y los dispositivos asociados. Los desarrolladores deben mantenerse actualizados con las últimas tendencias y tecnologías para crear aplicaciones exitosas y competitivas en el ecosistema de iOS.


## Classic Mac OS:

- **Creador o Compañía:** Apple Inc.
- **Fecha de lanzamiento:** Originalmente en 1984 con el Macintosh 128K. La última versión, Mac OS 9, se lanzó en 1999.
- **Costo por licencia:** Los precios variaban según la versión y las actualizaciones. Las últimas versiones solían ser gratuitas.
- **Tipo de núcleo (CPU):** Monolítico
- **Tipo de Kernel:** No tiene un kernel en el sentido moderno.
- **Arquitectura soportada:** Principalmente para procesadores Motorola 68k y PowerPC.
- **Procesador gráfico:** Dependía del modelo de Macintosh.
- **% de usuarios en el mundo:** Actualmente, es prácticamente nulo, ya que fue descontinuado.
- **% de usuarios en México:** Similar al mundo.
- **Sistemas de archivos soportados:** HFS (Hierarchical File System).
- **Firewall:** No tenía un firewall incorporado.

## OS X (macOS):

- **Creador o Compañía:** Apple Inc.
- **Fecha de lanzamiento:** La primera versión, Mac OS X 10.0, se lanzó en 2001.
- **Costo por licencia:** En un momento, macOS era de pago, pero desde OS X 10.9 Mavericks, Apple lo ha ofrecido de forma gratuita.
- **Tipo de núcleo (CPU):** XNU (X is Not Unix) basado en Mach.
- **Tipo de Kernel:** Híbrido (microkernel y monolítico).
- **Arquitectura soportada:** Originalmente PowerPC y luego Intel x86. Desde 2020, solo Intel y Apple Silicon (M1).
- **Procesador gráfico:** Variaba según el modelo de Mac.
- **% de usuarios en el mundo:** Variable, pero significativo, especialmente en el mercado de las computadoras personales.
- **% de usuarios en México:** Similar al mundo.
- **Sistemas de archivos soportados:** HFS+, APFS.
- **Firewall:** Sí, macOS incluye un firewall incorporado.

## OS X Server:

- **Creador o Compañía:** Apple Inc.
- **Fecha de lanzamiento:** La versión original se lanzó en 1999.
- **Costo por licencia:** Varía según la versión y la cantidad de usuarios. Ha habido versiones gratuitas y de pago.
- **Tipo de núcleo (CPU):** XNU (X is Not Unix) basado en Mach.
- **Tipo de Kernel:** Híbrido (microkernel y monolítico).
- **Arquitectura soportada:** Originalmente PowerPC y luego Intel x86. Desde 2020, Apple Silicon (M1).
- **Procesador gráfico:** Depende del servidor y la configuración.
- **% de usuarios en el mundo:** Muy bajo en comparación con las versiones de escritorio.
- **% de usuarios en México:** Similar al mundo.
- **Sistemas de archivos soportados:** HFS+, APFS.
- **Firewall:** Sí, incluye un firewall incorporado.

## macOS Ventura (13):

--Pendiente

## Microsoft Windows 10:

- **Creador o Compañía:** Microsoft Corporation.
- **Fecha de lanzamiento:** Windows 10 se lanzó el 29 de julio de 2015.
- **Costo por licencia:** Inicialmente, se ofrecía como una actualización gratuita para usuarios de Windows 7 y 8. Luego, Microsoft implementó un modelo de suscripción llamado Windows 10 Enterprise E3/E5, además de las licencias individuales de Windows 10 Home y Pro.
- **Tipo de núcleo (CPU):** x86, x64, ARM.
- **Tipo de Kernel:** Monolítico.
- **Arquitectura soportada:** Principalmente x86 y x64, pero también ARM en ciertos dispositivos.
- **Procesador gráfico:** Variará según la configuración del hardware.
- **% de usuarios en el mundo:** Windows 10 ha sido una de las versiones más utilizadas de Windows en todo el mundo, pero la participación de mercado puede variar con el tiempo.
- **% de usuarios en México:** Similar a la participación de mercado mundial.
- **Sistemas de archivos soportados:** NTFS, FAT32, exFAT, ReFS.
- **Firewall:** Sí, Windows 10 incluye el Firewall de Windows.

## Linux Ubuntu:

- **Creador o Compañía:** Canonical Ltd.
- **Fecha de lanzamiento:** La primera versión de Ubuntu, 4.10 "Warty Warthog," se lanzó en octubre de 2004.
- **Costo por licencia:** Ubuntu se distribuye bajo licencia GNU GPL y es de código abierto, por lo que es gratuito.
- **Tipo de núcleo (CPU):** x86, x64, ARM, PowerPC, entre otros.
- **Tipo de Kernel:** Monolítico (kernel de Linux).
- **Arquitectura soportada:** Amplia gama de arquitecturas, pero las versiones más populares son para x86 y x64.
- **Procesador gráfico:** Variará según la configuración del hardware y la versión de Ubuntu.
- **% de usuarios en el mundo:** Ubuntu es una de las distribuciones de Linux más populares, pero su participación de mercado es menor que la de Windows y macOS.
- **% de usuarios en México:** Similar a la participación de mercado mundial.
- **Sistemas de archivos soportados:** ext4, ext3, ZFS (opcional), entre otros.
- **Firewall:** Ubuntu incluye el firewall iptables, pero debe configurarse según las necesidades del usuario.

## Xcode:

**Definición completa:**
Xcode es un IDE (Integrated Development Environment) desarrollado por Apple que permite a los programadores crear aplicaciones para los sistemas operativos macOS, iOS, watchOS y tvOS. Proporciona un conjunto completo de herramientas de desarrollo, incluido un editor de código, depurador, simuladores de dispositivos, gestión de proyectos y más.

**Historia:**
Xcode se lanzó por primera vez en 2003. El nombre "Xcode" proviene de la combinación de "X" de macOS y "code" (código en inglés). Ha experimentado numerosas actualizaciones a lo largo de los años para incluir nuevas características y mejoras en el desarrollo de aplicaciones para dispositivos Apple.

**Versiones:**
Xcode ha tenido numerosas versiones a lo largo de los años, y cada versión suele estar destinada a ser compatible con las últimas versiones de los sistemas operativos de Apple (macOS, iOS, watchOS y tvOS). Cada versión suele agregar soporte para los lenguajes de programación más recientes, como Swift y Objective-C. La disponibilidad de lenguajes y características puede variar según la versión específica de Xcode.

**nib, xib, storyboard:**
- **nib:** Archivo binario de interfaz de usuario utilizado en el desarrollo de aplicaciones macOS.
- **xib:** Archivo XML de interfaz de usuario utilizado en el desarrollo de aplicaciones macOS e iOS. Fue reemplazado por los storyboards en el desarrollo de iOS.
- **storyboard:** Archivo visual utilizado en el desarrollo de aplicaciones iOS que permite diseñar la interfaz de usuario y definir las transiciones entre pantallas de manera gráfica.

**App Store:**
Para publicar aplicaciones en la App Store de Apple, debes cumplir con ciertos requisitos, como tener una cuenta de desarrollador de Apple, seguir las pautas de diseño y seguridad de Apple, pasar la revisión de la App Store, etc. Además, es necesario utilizar Xcode para construir y empaquetar la aplicación antes de enviarla para su revisión.

**Estructura de una App empaquetada:**
Una aplicación empaquetada para macOS, iOS, watchOS o tvOS consta de varios componentes, incluidos ejecutables, recursos y archivos de configuración. Estos componentes se organizan en una estructura de directorio específica dentro del paquete de la aplicación.

**Modelo-Vista-Controlador (MVC):**
El patrón de diseño Modelo-Vista-Controlador es un enfoque arquitectónico utilizado en el desarrollo de aplicaciones de software. En el contexto de Xcode:
- **Modelo:** Representa los datos y la lógica empresarial de la aplicación.
- **Vista:** Representa la interfaz de usuario de la aplicación.
- **Controlador:** Actúa como intermediario entre el Modelo y la Vista, gestionando la lógica y la interacción del usuario.

**Simuladores soportados:**
Xcode proporciona simuladores para varios dispositivos iOS, watchOS y tvOS, lo que permite probar aplicaciones en entornos virtuales antes de implementarlas en hardware físico.

**Instruments:**
Instruments es una herramienta de análisis de rendimiento integrada en Xcode que permite realizar un seguimiento del rendimiento y el comportamiento de una aplicación en ejecución, ayudando a identificar problemas de rendimiento, fugas de memoria y otros problemas.

**Programa de desarrolladores de Apple:**
El Programa de Desarrolladores de Apple permite a los desarrolladores acceder a recursos, herramientas y documentación necesarios para crear aplicaciones para dispositivos Apple y publicarlas en la App Store. Ofrece varios niveles de membresía, incluida una membresía gratuita y opciones pagas.

**Ventana de un proyecto:**
Una ventana de proyecto en Xcode es la interfaz de usuario principal donde los desarrolladores pueden administrar y trabajar en su proyecto de desarrollo de aplicaciones. Incluye diversas áreas, como el editor de código, el inspector, el navegador de archivos, entre otros.

**Panel de navegación, Panel de utilerías y Panel de depuración:**
- **Panel de navegación:** Muestra la estructura de archivos y grupos de un proyecto, lo que facilita la navegación y administración de archivos.
- **Panel de utilerías:** Proporciona herramientas para editar propiedades y configuraciones de elementos seleccionados en la interfaz de usuario, como vistas y controles.
- **Panel de depuración:** Proporciona información y herramientas para depurar la aplicación, incluido el visor de consola, registros y depuración en tiempo real.

## Swift:

**Definición completa:**
Swift es un lenguaje de programación desarrollado por Apple que se utiliza para crear aplicaciones para sistemas operativos como iOS, macOS, watchOS y tvOS. Es un lenguaje de programación moderno y de alto nivel que se ha convertido en la principal opción para el desarrollo de aplicaciones en la plataforma Apple.

**Historia:**
- **Origen del nombre y logo:** El nombre "Swift" se eligió porque representa velocidad y eficiencia. El logo de Swift es un par de alas estilizadas que reflejan la velocidad y la agilidad del lenguaje.

**Paradigmas de programación que soporta:**
- Programación orientada a objetos: Swift admite programación orientada a objetos, lo que significa que puedes crear objetos que encapsulan datos y comportamientos relacionados.
- Programación orientada a protocolos: Swift fomenta la programación orientada a protocolos, lo que permite definir comportamientos comunes mediante protocolos y hacer que los tipos se adhieran a ellos.

**Tipo de licenciamiento:**
Swift se distribuye bajo una licencia de código abierto, lo que significa que es gratuito y está disponible para que cualquiera lo use, modifique y distribuya.

**Playground:**
Playground es una característica de desarrollo en Xcode que permite a los desarrolladores escribir código Swift de manera interactiva y ver los resultados en tiempo real.

**Prototipos en Playground:**
Los Playground se utilizan para crear prototipos rápidos de código Swift y experimentar con diferentes algoritmos o ideas antes de incorporarlos a una aplicación completa.

**Prototipos de apps y juegos:**
Los desarrolladores pueden utilizar Playground para crear prototipos de aplicaciones y juegos simples utilizando Swift, lo que les permite visualizar y experimentar con ideas antes de implementarlas completamente.

**Sintaxis:**
- Comentarios: Los comentarios se pueden agregar al código usando // para comentarios de una sola línea o /* */ para comentarios de varias líneas.
- Uso de punto y coma: En Swift, el uso del punto y coma al final de las declaraciones es opcional.
- Nomenclatura de identificadores: Se recomienda utilizar nombres descriptivos para variables, constantes, funciones y otros identificadores en Swift.
- Literales: Swift admite literales para tipos de datos como números enteros, flotantes, cadenas y más.
- Tipos de datos: Los tipos de datos en Swift incluyen Int, Float, Double, String, Bool y muchos otros. También admite tipos de datos compuestos como arrays, diccionarios y rangos.
- Alias de tipos: Puedes crear alias de tipos utilizando la palabra clave typealias.
- Inferencia de tipos: Swift utiliza inferencia de tipos, lo que significa que el tipo de una variable o constante se deduce automáticamente según el valor asignado.
- Declaración de variables y constantes: Las variables se declaran con var y las constantes con let.
- Nomenclatura de variables y constantes: Swift permite el uso de caracteres Unicode especiales en los nombres de variables y constantes.
- Tipo de dato Optional: Swift introduce el concepto de opciónals para representar valores nulos o ausentes de manera segura.
- Secuencias de escape: Se utilizan secuencias de escape, como \n para nueva línea o \t para tabulación, en cadenas.

**Operadores:**
- Aritméticos: +, -, *, /, %, etc.
- Relacionales: ==, !=, <, >, <=, >=, etc.
- Lógicos: &&, ||, !
- Bit a bit (bitwise): &, |, ^, ~, <<, >>
- Asignación: =, +=, -=, *=, /=, %=, etc.
- Rango: ..< (semicerrado), ... (cerrado).
- Condicional ternaria: condición ? valorTrue : valorFalse.

**Decisiones:** if, else, switch.

**Ciclos:** for-in, while, repeat-while.

## Cocoa, Cocoa Touch y Foundation:

**Conceptos:**

- **Framework:** Un framework es una estructura o conjunto de bibliotecas de software que proporciona una base para el desarrollo de aplicaciones. Los frameworks incluyen una serie de funciones y componentes predefinidos que permiten a los desarrolladores crear aplicaciones de manera más rápida y eficiente al aprovechar funcionalidades ya existentes.

- **API (Interfaz de Programación de Aplicaciones):** Una API es un conjunto de reglas y protocolos que permiten que diferentes componentes de software se comuniquen entre sí. Las API definen las operaciones que se pueden realizar y cómo se deben realizar, proporcionando un conjunto de funciones y métodos que los desarrolladores pueden utilizar para interactuar con una biblioteca, sistema operativo o servicio.

**Cocoa:**

- **Definición completa:** Cocoa es un framework de desarrollo de software proporcionado por Apple para la creación de aplicaciones en macOS. Incluye una serie de bibliotecas y componentes que simplifican el desarrollo de aplicaciones para la plataforma macOS.

- **Historia:** El nombre "Cocoa" se originó en el sistema operativo NeXTSTEP, desarrollado por NeXT Computer Inc., la compañía fundada por Steve Jobs después de dejar Apple. Cuando Apple adquirió NeXT en 1997, incorporó muchas de las tecnologías de NeXTSTEP en su plataforma, incluido el framework Cocoa. Cocoa se convirtió en el marco de desarrollo principal para aplicaciones macOS.

- **Frameworks que contiene:** Cocoa contiene varios subframeworks, incluyendo Cocoa Touch para desarrollo de aplicaciones iOS y watchOS, así como AppKit para aplicaciones macOS.

**Cocoa Touch:**

- **Definición completa:** Cocoa Touch es una variante del framework Cocoa diseñada específicamente para el desarrollo de aplicaciones en iOS (incluidos iPhone y iPad) y watchOS (para Apple Watch). Proporciona bibliotecas y herramientas para crear aplicaciones móviles y de reloj para dispositivos Apple.

**Foundation:**

- **Definición completa:** Foundation es un framework de desarrollo proporcionado por Apple que ofrece una amplia variedad de clases y funcionalidades básicas para el desarrollo de aplicaciones en macOS, iOS, watchOS y tvOS. Es esencialmente la base sobre la que se construyen otros frameworks de Apple.

- **Historia:** Foundation tiene sus raíces en el sistema operativo NeXTSTEP desarrollado por NeXT Computer Inc. Cuando Apple adquirió NeXT en 1997, Foundation se convirtió en la base de muchas de las bibliotecas de Cocoa y Cocoa Touch.

**Arquitectura de algunos frameworks relacionados:**

- **Core Audio:** Proporciona funcionalidades de audio de bajo nivel y alto rendimiento.

- **Core Data:** Es un framework utilizado para la gestión de datos y almacenamiento persistente en aplicaciones.

- **Core Image:** Proporciona herramientas para el procesamiento y manipulación de imágenes en tiempo real.

- **Core Animation:** Se utiliza para crear animaciones suaves y fluidas en la interfaz de usuario.

- **Bonjour:** Permite la comunicación en red entre dispositivos en una red local.

- **Core Location:** Proporciona información de ubicación y servicios de geolocalización.

- **UIKit:** Es el framework principal para el desarrollo de aplicaciones de usuario en iOS y tvOS. Incluye componentes de interfaz de usuario como botones, vistas y controladores.

Estos frameworks son fundamentales en el desarrollo de aplicaciones para las plataformas de Apple y permiten a los desarrolladores acceder a una amplia gama de funcionalidades para crear aplicaciones efectivas y atractivas.

## Arquitectura Swift:

**Estructura de un archivo (código fuente):**

- En Swift, un archivo de código fuente generalmente tiene la extensión ".swift".
- Un archivo Swift puede contener una o más declaraciones de clase, estructuras, enumeraciones, funciones, propiedades y más.
- El código se organiza en un conjunto de declaraciones en el archivo que pueden incluir importaciones de módulos externos, declaraciones de tipo, definiciones de clases y estructuras, funciones, etc.

**Estructura de un archivo IPA:**

- Un archivo IPA (iOS App Store Package) es un archivo comprimido que contiene una aplicación iOS completa, incluido su código binario, recursos y metadatos.
- La estructura interna de un archivo IPA es compleja y contiene una variedad de archivos y carpetas, incluidos los binarios de la aplicación, archivos de recursos, perfiles de aprovisionamiento, información de iconos, entre otros.

**Espacios de nombres:**

- En Swift, los espacios de nombres son utilizados para evitar conflictos de nombres entre diferentes módulos, tipos y funciones.
- Los nombres únicos se logran a través de la definición de módulos y el uso de la notación de punto (por ejemplo, UIKit.UIViewController), lo que permite referirse a tipos específicos en diferentes módulos.

**Módulos:**

- Los módulos en Swift son unidades de organización de código que agrupan tipos, funciones y otros elementos relacionados.
- Los módulos permiten controlar la visibilidad de los elementos dentro y fuera del módulo utilizando las palabras clave import, public, internal, private, etc.

**Instancias:**

- En Swift, una instancia es una representación de un tipo definido, como una clase o estructura, que se crea en tiempo de ejecución.
- Las instancias se crean utilizando el inicializador del tipo y se pueden acceder a través de variables o constantes.

**Sintaxis en Swift:**

**Condicionales:**

La estructura de una declaración condicional en Swift utiliza if, else if y else para tomar decisiones basadas en condiciones.

```swift
if condición {
    // Código a ejecutar si la condición es verdadera
} else if otraCondición {
    // Código a ejecutar si la primera condición es falsa y esta es verdadera
} else {
    // Código a ejecutar si todas las condiciones anteriores son falsas
}
```

## Arreglos:

Los arreglos en Swift se crean utilizando `[Tipo]` y pueden contener elementos del mismo tipo.

```swift
var miArreglo: [Int] = [1, 2, 3]
```
## Funciones:

Las funciones en Swift se definen con la palabra clave `func`.

```swift
func saludar(nombre: String) -> String {
    return "Hola, \(nombre)!"
}
```

## Tuplas:

Las tuplas son colecciones ordenadas de valores que pueden ser de diferentes tipos.

```swift
let coordenadas = (x: 10, y: 20)
```

## Enumeraciones:

Las enumeraciones en Swift definen un conjunto fijo de valores relacionados.

```swift
enum DíaSemana {
    case lunes, martes, miércoles, jueves, viernes
}
```

## Diccionarios:

Los diccionarios en Swift se crean utilizando `[Clave: Valor]` y almacenan pares clave-valor.

```swift
var miDiccionario: [String: Int] = ["uno": 1, "dos": 2, "tres": 3]
```

## Clases:

Las clases en Swift se definen con la palabra clave `class` y permiten crear tipos de referencia.

```swift
class Persona {
    var nombre: String
    init(nombre: String) {
        self.nombre = nombre
    }
}
```
## Propiedades:

Las propiedades en una clase son variables o constantes que almacenan valores.

```swift
class Persona {
    var nombre: String
    let edad: Int
    init(nombre: String, edad: Int) {
        self.nombre = nombre
        self.edad = edad
    }
}
```
## Métodos:

Los métodos son funciones que están asociadas con una clase y pueden acceder a sus propiedades.

```swift
class Persona {
    var nombre: String
    init(nombre: String) {
        self.nombre = nombre
    }
    func saludar() {
        print("Hola, soy \(nombre).")
    }
}
```

## Conclusiones

En este resumen se ha proporcionado información detallada sobre varios aspectos relacionados con el desarrollo de aplicaciones para plataformas Apple, así como sobre el lenguaje de programación Swift y los frameworks clave utilizados en este entorno. A continuación, se resaltan algunas conclusiones clave:

- **Plataformas Apple**: Apple ofrece una variedad de sistemas operativos, incluidos macOS, iOS, watchOS y tvOS, que son compatibles con diferentes tipos de dispositivos, como Macs, iPhones, iPads, Apple Watches y Apple TVs.

- **Historia de los Sistemas Operativos**: Se ha proporcionado información sobre la historia de los sistemas operativos de Apple, desde el clásico Mac OS hasta las versiones más recientes de macOS y iOS.

- **Xcode y Swift**: Xcode es el entorno de desarrollo integrado (IDE) de Apple que se utiliza para crear aplicaciones para las plataformas de Apple. Swift es el lenguaje de programación moderno desarrollado por Apple para el desarrollo de aplicaciones en estas plataformas.

- **Frameworks de Desarrollo**: Cocoa, Cocoa Touch y Foundation son frameworks clave proporcionados por Apple que simplifican el desarrollo de aplicaciones en sus plataformas. Cada uno de ellos tiene un enfoque específico: Cocoa para macOS, Cocoa Touch para iOS y watchOS, y Foundation como base común.

- **Estructura de Código en Swift**: Se ha presentado la estructura de un archivo de código fuente en Swift, incluyendo la definición de módulos, espacios de nombres, instancias y más.

- **Sintaxis en Swift**: Se han proporcionado ejemplos de sintaxis en Swift para condicionales, arreglos, funciones, tuplas, enumeraciones, diccionarios, clases, propiedades y métodos.

## Recomendaciones

- Para el desarrollo de aplicaciones en plataformas Apple, es fundamental familiarizarse con Xcode y Swift. Estas herramientas son esenciales y proporcionan un entorno de desarrollo poderoso.

- Antes de comenzar a desarrollar una aplicación, es importante tener una comprensión sólida de los fundamentos de la programación en Swift, incluyendo conceptos como variables, funciones, condicionales y bucles.

- Aproveche los recursos de documentación y tutoriales proporcionados por Apple. La documentación oficial y la comunidad de desarrolladores de Apple son recursos valiosos para resolver problemas y aprender mejores prácticas.

- Considere la usabilidad y el diseño de su aplicación. Apple pone un fuerte énfasis en la experiencia del usuario y el diseño de interfaz, por lo que es importante seguir las pautas de diseño de Apple.

- Si planea distribuir su aplicación en la App Store, asegúrese de comprender los requisitos y el proceso de revisión de la App Store. Cumplir con los estándares de Apple es esencial para la aprobación de la aplicación.

- Manténgase actualizado con las últimas versiones de los sistemas operativos y herramientas de desarrollo de Apple, ya que pueden introducir nuevas características y mejoras que pueden beneficiar a su aplicación.

- No dude en utilizar la depuración y las herramientas de análisis de rendimiento proporcionadas por Xcode para identificar y solucionar problemas en su aplicación.

- Explore y experimente con los diversos frameworks y bibliotecas disponibles en las plataformas Apple para aprovechar al máximo las capacidades de hardware y software de los dispositivos.

- Finalmente, la práctica constante es clave para convertirse en un desarrollador hábil en el entorno de Apple. Cuanto más desarrolle y depure aplicaciones, más experiencia ganará.

Con estas recomendaciones y un enfoque de aprendizaje continuo, estará bien encaminado para desarrollar aplicaciones exitosas en las plataformas Apple utilizando Swift y Xcode. ¡Buena suerte en su viaje de desarrollo!

-----

# Practicas de programacion

## Conversión de la Edad de un Perro a Edad Humana

### Explicación Breve:
En este código, se realiza una conversión de la edad de un perro a su equivalente en edad humana utilizando una fórmula comúnmente aceptada. El objetivo es calcular cuántos años humanos tendría un perro según su edad en años perros.

### Pasos de la Realización:

* Inicialización de la variable ageDog con un valor de 50, que representa la edad del perro en años caninos.

* Creación de la función getAgeHuman, que toma un parámetro age de tipo entero (que representa la edad del perro) y realiza el cálculo para obtener la edad equivalente en años humanos.

* Dentro de la función getAgeHuman, se utiliza la fórmula age / 7 para calcular la edad en años humanos. Esto se basa en una regla general que establece que 1 año de perro es aproximadamente equivalente a 7 años humanos.

* Se utiliza la función print para mostrar el resultado en la consola, indicando cuántos años humanos tendría el perro.

### Resultados Obtenidos:
La conversión de la edad del perro a años humanos se realiza correctamente y se muestra en la consola.

### Sentencias Completas:

```swift
let ageDog = 50

func getAgeHuman (age: Int) {
    print("El perro tiene:", age / 7, "Años")
}

getAgeHuman(age: ageDog)

```

### Consideraciones:

La fórmula utilizada para convertir la edad de un perro a años humanos es una aproximación y puede variar según la raza y el tamaño del perro.
Este código asume que la variable ageDog contiene la edad del perro en años caninos antes de llamar a la función getAgeHuman.

### Resultados Obtenidos (Explicación):
El código tomará la edad del perro (50 años) y aplicará la fórmula de conversión, dividiendo la edad del perro por 7. El resultado será 7, lo que significa que el perro tiene aproximadamente 7 años humanos. Esta información se mostrará en la consola como "El perro tiene: 7 Años".

----

## Cálculo de Velocidad en Diferentes Unidades

### Explicación Breve:
En este código, se calcula la velocidad en diferentes unidades (metros por segundo, kilómetros por hora y millas por hora) a partir de una distancia en metros y un tiempo en horas, minutos y segundos dados. El objetivo es determinar la velocidad a la que se está moviendo un objeto.

### Pasos de la Realización:

- Se inicializan las variables `hora`, `minutos`, `segundos` y `distanciaMts` con sus respectivos valores. Estos valores representan la hora actual (5 horas, 56 minutos, 23 segundos) y la distancia recorrida en metros (2500 metros).

- Se crea la función `getMts`, que realiza los cálculos necesarios para obtener la velocidad en diferentes unidades.

- Dentro de la función `getMts`, se calcula el tiempo total en segundos utilizando la fórmula `(hora * 3600) + (minutos * 60) + segundos`.

- Luego, se calcula la velocidad en metros por segundo dividiendo la distancia en metros (`distanciaMts`) por el tiempo total en segundos.

- Se calcula la velocidad en kilómetros por hora multiplicando la velocidad en metros por segundo por 3.6 (ya que 1 metro por segundo es igual a 3.6 kilómetros por hora).

- Se calcula la velocidad en millas por hora multiplicando la velocidad en metros por segundo por 2.237 (aproximadamente, ya que 1 metro por segundo es igual a aproximadamente 2.237 millas por hora).

- Finalmente, se utilizan las funciones `print` para mostrar los resultados en la consola, indicando la velocidad en metros por segundo, kilómetros por hora y millas por hora.

### Resultados Obtenidos:
La velocidad en diferentes unidades se calcula correctamente y se muestra en la consola.

### Sentencias Completas:

```swift
var hora = 5
var minutos = 56
var segundos = 23
var distanciaMts = 2500

func getMts() {
    let secondTotal = Float((hora * 3600) + (minutos * 60) + segundos)
    let velocityOnSeconds = Float(distanciaMts) / secondTotal
    let velocityKmPorHora = velocityOnSeconds * 3.6
    let velocityMillasPorHora = velocityOnSeconds * 2.237 
    print(velocityOnSeconds,"Metros por segundo")
    print(velocityKmPorHora, "Kilometros por hora")
    print(velocityMillasPorHora, "mph")
}

getMts()

```

### Consideraciones:
Este código asume que las variables hora, minutos, segundos y distanciaMts contienen valores válidos antes de llamar a la función getMts.

### Resultados Obtenidos (Explicación):
El código calcula la velocidad utilizando la fórmula de velocidad = distancia / tiempo. Primero, convierte el tiempo total en segundos y luego divide la distancia en metros por este tiempo para obtener la velocidad en metros por segundo. Luego, se convierte esta velocidad a kilómetros por hora y millas por hora. Los resultados se muestran en la consola, proporcionando la velocidad en diferentes unidades.

----

## Cálculo de Valores de 'a' y 'b'

### Explicación Breve:
En este código, se calculan los valores de 'a' y 'b' utilizando las variables 'suma' y 'diferencia'. El objetivo es determinar los valores de 'a' y 'b' de acuerdo con las fórmulas proporcionadas.

### Pasos de la Realización (Prueba 1):

- Se inicializan las variables 'suma' y 'diferencia' con los valores 16 y 4, respectivamente.

- Se calcula 'a' utilizando la fórmula `(suma + diferencia) / 2`.

- Se calcula 'b' restando 'a' de 'suma'.

- Se utilizan las funciones 'print' para mostrar los valores de 'a' y 'b' en la consola.

### Resultados Obtenidos (Prueba 1):
Los valores de 'a' y 'b' se calculan correctamente y se muestran en la consola.

### Sentencias Completas (Prueba 1):

```swift
let suma = 16
let diferencia = 4

let a = (suma + diferencia) / 2
let b = suma - a

print("El valor de a es:", a)
print("El valor de b es:", b)

```

### Pasos de la Realización (Prueba 2):
Se inicializan las variables 'suma' y 'diferencia' con los valores 11 y 3, respectivamente.

Se calcula 'a' utilizando la fórmula (suma + diferencia) / 2.

Se calcula 'b' restando 'a' de 'suma'.

Se utilizan las funciones 'print' para mostrar los valores de 'a' y 'b' en la consola.

### Resultados Obtenidos (Prueba 2):
Los valores de 'a' y 'b' se calculan correctamente y se muestran en la consola.

```swift
let suma = 11
let diferencia = 3

let a = (suma + diferencia) / 2
let b = suma - a

print("El valor de a es:", a)
print("El valor de b es:", b)

```

### Consideraciones:
Este código asume que las variables 'suma' y 'diferencia' contienen valores válidos antes de realizar los cálculos.

----

## Cálculo de Perímetro y Área de una Figura

### Explicación Breve:
En este código, se calcula el perímetro y el área de una figura geométrica a partir de su ancho, alto, y las coordenadas de dos de sus vértices. Se utilizan dos funciones: `calcularPerimetro` y `calcularArea` para realizar los cálculos necesarios.

### Pasos de la Realización:

- Se importa la librería Foundation para utilizar funciones matemáticas y de impresión.

- Se define la función `calcularPerimetro` que toma como parámetros el ancho, alto y las coordenadas x e y de uno de los vértices de la figura. La función calcula el perímetro sumando las longitudes de los lados de la figura.

- Se define la función `calcularArea` que toma los mismos parámetros que `calcularPerimetro`. Esta función calcula el área de la figura dividiéndola en dos rectángulos y sumando sus áreas.

- Se inicializan las variables `anchoPrueba1`, `altoPrueba1`, `xPrueba1`, y `yPrueba1` con valores de prueba.

- Se calcula el perímetro y el área de la figura utilizando las funciones `calcularPerimetro` y `calcularArea` con los valores de prueba.

- Se utilizan las funciones `print` para mostrar el resultado de la prueba en la consola.

### Resultados Obtenidos:
El código calcula el perímetro y el área de la figura correctamente y muestra los resultados en la consola.

### Sentencias Completas:

```swift
import Foundation

func calcularPerimetro(ancho: Double, alto: Double, x: Double, y: Double) -> Double {
    let ladoHorizontalSuperior = ancho + x
    let ladoVertical = alto + y
    let ladoHorizontalInferior = ancho
    let perimetro = ladoHorizontalSuperior + ladoVertical + ladoHorizontalInferior
    return perimetro
}

func calcularArea(ancho: Double, alto: Double, x: Double, y: Double) -> Double {
    let areaSuperior = (ancho + x) * alto
    let areaInferior = ancho * y
    let areaTotal = areaSuperior + areaInferior
    return areaTotal
}

let anchoPrueba1 = 8.0
let altoPrueba1 = 12.0
let xPrueba1 = 4.0
let yPrueba1 = 3.0

let perimetroPrueba1 = calcularPerimetro(ancho: anchoPrueba1, alto: altoPrueba1, x: xPrueba1, y: yPrueba1)
let areaPrueba1 = calcularArea(ancho: anchoPrueba1, alto: altoPrueba1, x: xPrueba1, y: yPrueba1)

print("Prueba 1:")
print("Perímetro:", perimetroPrueba1)
print("Área:", areaPrueba1)

```

### Consideraciones:
Este código asume que los valores de anchoPrueba1, altoPrueba1, xPrueba1, y yPrueba1 contienen valores válidos antes de realizar los cálculos.

---

## Extracción del Último Dígito de un Número Entero

### Explicación Breve:
En este código, se extrae el último dígito de un número entero y se imprime en la consola. El número se convierte primero en una cadena para facilitar la extracción del último dígito.

### Pasos de la Realización:

- Se inicializa la variable `a` con el valor 123.

- Se convierte el número entero `a` en una cadena utilizando la función `String(a)` y se almacena en la variable `numeroComoCadena`.

- Se utiliza un condicional `if let` para intentar obtener el último dígito de la cadena. Si se puede obtener el último dígito como una cadena, se convierte a un entero utilizando `Int(String(ultimoDigito))`.

- Se imprime el resultado que indica cuál es el último dígito del número original `a`.

### Resultados Obtenidos:
El código extrae el último dígito del número 123 correctamente y lo muestra en la consola.

### Sentencias Completas:

```swift
let a = 123

let numeroComoCadena = String(a)

if let ultimoDigito = numeroComoCadena.last {
    if let ultimoDigitoInt = Int(String(ultimoDigito)) {
        print("El último dígito de \(a) es \(ultimoDigitoInt)")
    }
}
```

### Consideraciones:
Este código asume que la variable a contiene un número entero válido antes de realizar los cálculos.

---

## Cálculo de Edad de Anahí

### Explicación Breve:
En este código, se calcula la edad de Anahí utilizando una fórmula basada en tres parámetros: `x`, `y`, y `abril`. Se utilizan dos pruebas diferentes con valores específicos para calcular la edad de Anahí en cada caso.

### Pasos de la Realización:

- Se importa la librería Foundation para utilizar funciones matemáticas.

- Se define la función `calcularEdadAnahi` que toma tres parámetros: `x`, `y`, y `abril`. La función realiza un cálculo basado en estos valores y devuelve la edad de Anahí.

- Se inicializan las variables `prueba1_x`, `prueba1_y`, `prueba1_abril`, `prueba2_x`, `prueba2_y`, y `prueba2_abril` con valores específicos para dos pruebas diferentes.

- Se calcula la edad de Anahí para cada prueba utilizando la función `calcularEdadAnahi`.

- Se utiliza la función `print` para mostrar los resultados de las pruebas en la consola.

### Resultados Obtenidos:
El código calcula la edad de Anahí para las dos pruebas diferentes y muestra los resultados en la consola.

### Sentencias Completas:

```swift
import Foundation

func calcularEdadAnahi(x: Int, y: Int, abril: Int) -> Int {
    let anahi = y * (abril + x) - x
    return anahi
}

let prueba1_x = 3
let prueba1_y = 2
let prueba1_abril = 12

let prueba2_x = 1
let prueba2_y = 3
let prueba2_abril = 12

let edadAnahiPrueba1 = calcularEdadAnahi(x: prueba1_x, y: prueba1_y, abril: prueba1_abril)
let edadAnahiPrueba2 = calcularEdadAnahi(x: prueba2_x, y: prueba2_y, abril: prueba2_abril)

print("Prueba 1 - Edad de Anahí: \(edadAnahiPrueba1) años")
print("Prueba 2 - Edad de Anahí: \(edadAnahiPrueba2) años")
```

### Consideraciones:
Este código asume que los valores de las variables prueba1_x, prueba1_y, prueba1_abril, prueba2_x, prueba2_y, y prueba2_abril contienen valores válidos antes de realizar los cálculos.

---

## Intercambio de Manzanas por Naranjas

### Explicación Breve:
En este código, se realiza un intercambio de manzanas por naranjas. Se calcula cuántas naranjas se obtienen y cuántas manzanas quedan después de realizar intercambios completos. La relación es que 5 manzanas se intercambian por 3 naranjas.

### Pasos de la Realización:

- Se importa la librería Foundation para utilizar funciones matemáticas.

- Se define la función `realizarIntercambioManzanasNaranjas` que toma un parámetro `manzanas` de tipo entero. La función calcula cuántos intercambios completos de 5 manzanas por 3 naranjas se pueden hacer, cuántas naranjas se obtienen y cuántas manzanas quedan después del intercambio.

- Se inicializan las variables de prueba `prueba1_manzanas`, `prueba2_manzanas`, y `prueba3_manzanas` con diferentes valores.

- Se realiza el intercambio de manzanas por naranjas utilizando la función `realizarIntercambioManzanasNaranjas` en cada prueba.

- Se utiliza la función `print` para mostrar los resultados de las pruebas en la consola.

### Resultados Obtenidos:
El código calcula cuántas naranjas se obtienen y cuántas manzanas quedan después de realizar los intercambios en cada prueba y muestra los resultados en la consola.

### Sentencias Completas:

```swift
import Foundation

func realizarIntercambioManzanasNaranjas(manzanas: Int) -> (naranjasObtenidas: Int, manzanasRestantes: Int) {
    let intercambiosCompletos = manzanas / 5
    let naranjasObtenidas = intercambiosCompletos * 3
    let manzanasRestantes = manzanas % 5
    return (naranjasObtenidas, manzanasRestantes)
}

let prueba1_manzanas = 17
let prueba2_manzanas = 25
let prueba3_manzanas = 4

let resultadoPrueba1 = realizarIntercambioManzanasNaranjas(manzanas: prueba1_manzanas)
let resultadoPrueba2 = realizarIntercambioManzanasNaranjas(manzanas: prueba2_manzanas)
let resultadoPrueba3 = realizarIntercambioManzanasNaranjas(manzanas: prueba3_manzanas)

print("Prueba 1 - Naranjas obtenidas: \(resultadoPrueba1.naranjasObtenidas), Manzanas restantes: \(resultadoPrueba1.manzanasRestantes)")
print("Prueba 2 - Naranjas obtenidas: \(resultadoPrueba2.naranjasObtenidas), Manzanas restantes: \(resultadoPrueba2.manzanasRestantes)")
print("Prueba 3 - Naranjas obtenidas: \(resultadoPrueba3.naranjasObtenidas), Manzanas restantes: \(resultadoPrueba3.manzanasRestantes)")
```

### Consideraciones:
Este código asume que las variables de prueba prueba1_manzanas, prueba2_manzanas, y prueba3_manzanas contienen valores válidos antes de realizar los cálculos.

---

## Encontrar el Número Mayor

### Explicación Breve:
En este código, se encuentra el número mayor entre dos números enteros, `numeroA` y `numeroB`. Se utiliza la función `encontrarNumeroMayor` para realizar la comparación y determinar cuál es el número mayor.

### Pasos de la Realización:

- Se importa la librería Foundation para utilizar funciones matemáticas y de impresión.

- Se define la función `encontrarNumeroMayor` que toma dos parámetros de entrada, `numeroA` y `numeroB`, y compara los dos números para determinar cuál es el mayor. La función devuelve un mensaje que indica cuál es el número mayor o si son iguales.

- Se inicializan las variables `numero1` y `numero2` con valores diferentes.

- Se utiliza la función `encontrarNumeroMayor` para encontrar el número mayor entre `numero1` y `numero2`.

- Se utiliza la función `print` para mostrar el resultado en la consola.

### Resultados Obtenidos:
El código compara `numero1` y `numero2` y determina cuál es el número mayor, mostrando el resultado en la consola.

### Sentencias Completas:

```swift
import Foundation

func encontrarNumeroMayor(_ numeroA: Int, _ numeroB: Int) -> String {
    if numeroA > numeroB {
        return "\(numeroA) es el mayor"
    } else if numeroA < numeroB {
        return "\(numeroB) es el mayor"
    } else {
        return "Son iguales"
    }
}

let numero1 = 11
let numero2 = 22

let resultado = encontrarNumeroMayor(numero1, numero2)
print(resultado)
```

### Consideraciones:
Este código asume que las variables numero1 y numero2 contienen valores válidos antes de realizar la comparación.

---

## Determinar si un Número es Par o Impar

### Explicación Breve:
En este código, se determina si un número entero, `x`, es par o impar utilizando una condición simple. Si el número es divisible por 2 sin dejar residuo, se considera par; de lo contrario, se considera impar.

### Pasos de la Realización:

- Se importa la librería Foundation para utilizar funciones matemáticas y de impresión.

- Se inicializa la variable `x` con el valor 38.

- Se utiliza una estructura condicional `if` para verificar si `x` es divisible por 2 sin dejar residuo. Si es así, se imprime "Numero Par"; de lo contrario, se imprime "Numero Inpar".

- Se utiliza la función `print` para mostrar el resultado en la consola.

### Resultados Obtenidos:
El código determina si el número `x` es par o impar y muestra el resultado en la consola.

### Sentencias Completas:

```swift
import Foundation

let x = 38

if x % 2 == 0  {
    print("Número Par")
} else {
    print("Número Impar")
}
```

### Consideraciones:
Este código asume que la variable x contiene un valor válido antes de realizar la verificación.

---

## Determinar si un Número es Divisible por Otro

### Explicación Breve:
En este código, se verifica si un número entero `a` es divisible por otro número entero `b`. Se utiliza una condición para determinar si `a` es un múltiplo de `b` (es decir, si el residuo de la división es igual a cero).

### Pasos de la Realización:

- Se importa la librería Foundation para utilizar funciones matemáticas y de impresión.

- Se inicializan las variables `a` y `b` con valores 22 y 11, respectivamente.

- Se utiliza una estructura condicional `if` para verificar si el residuo de la división de `a` entre `b` es igual a cero. Si es así, se imprime "Es divisible"; de lo contrario, se imprime "No es divisible".

- Se utiliza la función `print` para mostrar el resultado en la consola.

### Resultados Obtenidos:
El código verifica si el número `a` es divisible por `b` y muestra el resultado en la consola.

### Sentencias Completas:

```swift
import Foundation

let a = 22
let b = 11

if a % b == 0 {
    print("Es divisible")
} else {
    print("No es divisible")
}
```

### Consideraciones:
Este código asume que las variables a y b contienen valores válidos antes de realizar la verificación.

---

## Verificar si al menos dos Variables son Iguales

### Explicación Breve:
En este código, se verifica si al menos dos de las tres variables enteras `a`, `b`, y `c` son iguales entre sí. Se utiliza una estructura condicional `if` para comparar las variables y determinar si se cumple la condición.

### Pasos de la Realización:

- Se importa la librería Foundation para utilizar funciones de impresión.

- Se inicializan las variables `a`, `b`, y `c` con valores 1, 2 y 3, respectivamente.

- Se utiliza una estructura condicional `if` con una condición compuesta utilizando el operador lógico `||` (OR) para verificar si `a` es igual a `b`, `a` es igual a `c`, o `b` es igual a `c`. Si al menos una de estas condiciones es verdadera, se imprime "Al menos dos variables son iguales"; de lo contrario, se imprime "Todas las variables son diferentes".

- Se utiliza la función `print` para mostrar el resultado en la consola.

### Resultados Obtenidos:
El código verifica si al menos dos de las variables `a`, `b`, y `c` son iguales y muestra el resultado en la consola.

### Sentencias Completas:

```swift
import Foundation

let a = 1
let b = 2
let c = 3

if a == b || a == c || b == c   {
   print("Al menos dos variables son iguales") 
} else {
    print("Todas las variables son diferentes")
}
```

### Consideraciones:
Este código asume que las variables a, b, y c contienen valores válidos antes de realizar la verificación.

---

## Verificar si se Pueden Cocinar Blanquillos y Tocino

### Explicación Breve:
En este código, se verifica si se pueden cocinar blanquillos y tocino en base a la cantidad disponible de cada uno. Se establecen condiciones para determinar si los ingredientes son válidos para cocinar y se muestra un mensaje en función de la disponibilidad de los ingredientes.

### Pasos de la Realización:

- Se importa la librería Foundation para utilizar funciones de impresión.

- Se inicializan las variables `blanquillos` y `tocino` con valores de 2 y 3, respectivamente.

- Se inicializan las variables `blanquillosValidos` y `tocinoValidos` como verdaderas (`true`) inicialmente.

- Se utilizan dos estructuras condicionales `if` para verificar si la cantidad de blanquillos es mayor que 21 o si la cantidad de tocino es mayor que 7. Si alguna de estas condiciones se cumple, se cambia el valor de la variable correspondiente a `false`, indicando que el ingrediente correspondiente no es válido.

- Se utiliza otra estructura condicional `if` para determinar el resultado en base a la disponibilidad de los ingredientes. Si ambas variables son `true`, se imprime "Ambos se pueden cocinar". Si ambas variables son `false`, se imprime "Desechar ambos". Si solo una de las variables es `false`, se imprime el mensaje correspondiente.

- Se utiliza la función `print` para mostrar el resultado en la consola.

### Resultados Obtenidos:
El código verifica si se pueden cocinar blanquillos y tocino en función de la cantidad disponible de cada uno y muestra el resultado en la consola.

### Sentencias Completas:

```swift
import Foundation

let blanquillos = 2
let tocino = 3
var blanquillosValidos = true
var tocinoValidos = true

if blanquillos > 21 {
    blanquillosValidos = false
}
if tocino > 7 {
    tocinoValidos = false
}

if blanquillosValidos && tocinoValidos {
    print("Ambos se pueden cocinar")
} else if !blanquillosValidos && !tocinoValidos {
    print("Desechar ambos")
} else if !blanquillosValidos {
    print("Desechar los blanquillos")
} else if !tocinoValidos {
    print("Desechar el tocino")
}

```

### Consideraciones:
Este código asume que las variables blanquillos y tocino contienen valores válidos antes de realizar las verificaciones.

---

## Verificar si un Año es Bisiesto

### Explicación Breve:
En este código, se verifica si un año (representado por la variable `anio`) es bisiesto o no. Un año es bisiesto si es divisible por 4, excepto cuando es divisible por 100 pero no por 400. Se utiliza una estructura condicional para realizar esta verificación y mostrar el resultado.

### Pasos de la Realización:

- Se importa la librería Foundation para utilizar funciones de impresión.

- Se inicializa la variable `anio` con el valor 2016.

- Se utiliza una estructura condicional `if` para verificar dos condiciones:
  - Si el año es divisible por 4 (`anio % 4 == 0`) o
  - Si el año es divisible por 400 pero no por 100 (`anio % 400 == 0 && anio % 100 != 0`).
  - Si alguna de estas condiciones es verdadera, se imprime "Es Bisiesto"; de lo contrario, se imprime "No es Bisiesto".

- Se utiliza la función `print` para mostrar el resultado en la consola.

### Resultados Obtenidos:
El código verifica si el año `anio` es bisiesto o no y muestra el resultado en la consola.

### Sentencias Completas:

```swift
import Foundation

let anio = 2016

if anio % 4 == 0 || (anio % 400 == 0 && anio % 100 != 0) {
    print("Es Bisiesto")
} else {
    print("No es Bisiesto")
}
```

### Consideraciones:
Este código asume que la variable anio contiene un valor válido antes de realizar la verificación.

---

## Verificar si un Número Aleatorio es Par o Impar

### Explicación Breve:
En este código, se genera un número aleatorio entre 1 y 2 utilizando la función `Int.random(in: 1...2)` y luego se verifica si este número aleatorio es par o impar. Se utiliza una estructura condicional `if` para realizar la verificación y mostrar el resultado.

### Pasos de la Realización:

- Se importa la librería Foundation para utilizar funciones de generación de números aleatorios y de impresión.

- Se genera un número aleatorio `randomInt` entre 1 y 2 utilizando la función `Int.random(in: 1...2)`.

- Se utiliza una estructura condicional `if` para verificar si el número aleatorio `randomInt` es par (`randomInt % 2 == 0`). Si es así, se imprime "Es par"; de lo contrario, se imprime "Es impar".

- Se utiliza la función `print` para mostrar el resultado en la consola.

### Resultados Obtenidos:
El código genera un número aleatorio `randomInt` y verifica si es par o impar, mostrando el resultado en la consola.

### Sentencias Completas:

```swift
import Foundation

let randomInt = Int.random(in: 1...2)

if randomInt % 2 == 0 {
    print("Es par")
} else {
    print("Es impar")
}
```

### Consideraciones:
Este código genera un número aleatorio entre 1 y 2 en cada ejecución, por lo que el resultado puede variar.

---

## Verificar si un Punto está Dentro de un Plano Cartesiano

### Explicación Breve:
En este código, se verifica si un punto con coordenadas `(x, y)` está dentro de un plano cartesiano delimitado por dos puntos `(x1, y1)` y `(x2, y2)`. Se utiliza una estructura condicional `if` para realizar la verificación y mostrar el resultado.

### Pasos de la Realización:

- Se importa la librería Foundation para utilizar funciones de impresión.

- Se inicializan las variables `x`, `y`, `x1`, `y1`, `x2` y `y2` con valores específicos que representan las coordenadas del punto `(x, y)` y los límites del plano cartesiano.

- Se utiliza una estructura condicional `if` con una condición compuesta para verificar si `(x, y)` se encuentra dentro del plano cartesiano. La condición verifica si `x` está dentro del rango `(x1, x2)` y si `y` está dentro del rango `(y1, y2)`.

- Si la condición es verdadera, se imprime "Se encuentra dentro del plano"; de lo contrario, se imprime "Se encuentra fuera del plano".

- Se utiliza la función `print` para mostrar el resultado en la consola.

### Resultados Obtenidos:
El código verifica si el punto `(x, y)` se encuentra dentro del plano cartesiano definido por `(x1, y1)` y `(x2, y2)` y muestra el resultado en la consola.

### Sentencias Completas:

```swift
import Foundation

let x = 1
let y = 2
let x1 = 1
let y1 = 1
let x2 = 3
let y2 = 3

if (x >= x1 && x <= x2) && (y >= y1 && y <= y2)  {
    print("Se encuentra dentro del plano")
} else {
    print("Se encuentra fuera del plano")
}
```

### Consideraciones:
Este código asume que las variables x, y, x1, y1, x2 y y2 contienen valores válidos antes de realizar la verificación.

---

## Verificar el Tipo de una Variable en Swift

### Explicación Breve:
En este código, se verifica el tipo de una variable `entrada` y se muestra el tipo de datos en la consola utilizando la función `type(of:)`. Esto permite determinar el tipo de datos de la variable `entrada`.

### Pasos de la Realización:

- Se importa la librería Foundation para utilizar funciones de impresión y otras utilidades.

- Se inicializa la variable `entrada` con el valor 1.

- Se utiliza la función `type(of:)` para obtener el tipo de datos de la variable `entrada`.

- Se utiliza la función `print` para mostrar el tipo de datos en la consola.

### Resultados Obtenidos:
El código verifica y muestra el tipo de datos de la variable `entrada` en la consola.

### Sentencias Completas:

```swift
import Foundation

let entrada = 1

print(type(of: entrada))
```

### Consideraciones:
Este código asume que la variable entrada contiene un valor válido antes de verificar su tipo de datos.

---

## Determinar el Signo Zodiacal en Swift

### Explicación Breve:
En este código, se determina el signo zodiacal correspondiente a una fecha dada (mes y día) utilizando una función `determinarSignoZodiacal`. El código utiliza múltiples condicionales para verificar el rango de fechas y asignar el signo zodiacal adecuado.

### Pasos de la Realización:

- Se importa la librería Foundation para utilizar funciones de impresión.

- Se define la función `determinarSignoZodiacal` que toma dos parámetros: `mes` y `dia`. La función verifica el rango de fechas y asigna el signo zodiacal correspondiente utilizando múltiples condicionales `if`.

- Se utiliza la función `print` para mostrar el signo zodiacal calculado en la consola.

### Resultados Obtenidos:
El código determina el signo zodiacal correspondiente a la fecha proporcionada y muestra el resultado en la consola.

### Sentencias Completas:

```swift
import Foundation

func determinarSignoZodiacal(mes: Int, dia: Int) -> String {
    
    if (mes == 3 && dia >= 21) || (mes == 4 && dia <= 19) {
        return "Aries"
    } else if (mes == 4 && dia >= 20) || (mes == 5 && dia <= 20) {
        return "Tauro"
    } else if (mes == 5 && dia >= 21) || (mes == 6 && dia <= 20) {
        return "Géminis"
    } else if (mes == 6 && dia >= 21) || (mes == 7 && dia <= 22) {
        return "Cáncer"
    } else if (mes == 7 && dia >= 23) || (mes == 8 && dia <= 22) {
        return "Leo"
    } else if (mes == 8 && dia >= 23) || (mes == 9 && dia <= 22) {
        return "Virgo"
    } else if (mes == 9 && dia >= 23) || (mes == 10 && dia <= 22) {
        return "Libra"
    } else if (mes == 10 && dia >= 23) || (mes == 11 && dia <= 21) {
        return "Escorpio"
    } else if (mes == 11 && dia >= 22) || (mes == 12 && dia <= 21) {
        return "Sagitario"
    } else if (mes == 12 && dia >= 22) || (mes == 1 && dia <= 19) {
        return "Capricornio"
    } else if (mes == 1 && dia >= 20) || (mes == 2 && dia <= 18) {
        return "Acuario"
    } else {
        return "Piscis"
    }
}

let signo = determinarSignoZodiacal(mes: 12, dia: 21)
print("El signo zodiacal es: \(signo)")
```

### Consideraciones:
Este código asume que los valores de mes y dia proporcionados son válidos para determinar el signo zodiacal.

---

## Imprimir los Primeros N Cuadrados Perfectos en Swift

### Explicación Breve:
En este código, se define una función `imprimirCuadradosPerfectos` que imprime los primeros N cuadrados perfectos. Un cuadrado perfecto es un número entero que es igual al cuadrado de otro número entero. El código utiliza un bucle `while` para calcular y mostrar los cuadrados perfectos hasta alcanzar la cantidad deseada.

### Pasos de la Realización:

- Se importa la librería Foundation para utilizar funciones de impresión.

- Se define la función `imprimirCuadradosPerfectos` que toma un parámetro `n` (la cantidad de cuadrados perfectos que se deben imprimir).

- Se utiliza la declaración `guard` para asegurarse de que `n` sea un número positivo. Si `n` no es mayor que 0, la función retorna sin hacer nada.

- Se inicializan las variables `cuadrado` y `contador`. `cuadrado` representa el número que se elevará al cuadrado para obtener cuadrados perfectos, y `contador` lleva el registro de cuántos cuadrados perfectos se han encontrado.

- Se utiliza un bucle `while` que continúa hasta que se hayan encontrado `n` cuadrados perfectos. Dentro del bucle, se calcula el cuadrado perfecto actual, se imprime y se incrementan las variables `cuadrado` y `contador` para pasar al siguiente número.

- Los cuadrados perfectos se imprimen en la consola.

### Resultados Obtenidos:
El código calcula y muestra los primeros `n` cuadrados perfectos en la consola.

### Sentencias Completas:

```swift
import Foundation

func imprimirCuadradosPerfectos(_ n: Int) {
    guard n > 0 else {
        return
    }
    
    var cuadrado = 1
    var contador = 0
    
    while contador < n {
        let cuadradoPerfecto = cuadrado * cuadrado
        print(cuadradoPerfecto)
        
        cuadrado += 1
        contador += 1
    }
}

let n = 5
imprimirCuadradosPerfectos(n)
```

### Consideraciones:
Este código asume que el valor de n proporcionado es válido y mayor que cero.

---

## Imprimir Serie Alternada en Swift

### Explicación Breve:
En este código, se define una función `imprimirSerieAlternada` que genera y muestra una serie de números alternados que comienzan con 1 y terminan con `n`. Los números se organizan de manera que el primer número es seguido por el último, el segundo por el penúltimo y así sucesivamente. El código utiliza un bucle `for` para generar esta serie y luego la imprime en la consola.

### Pasos de la Realización:

- Se importa la librería Foundation para utilizar funciones de impresión y otras utilidades.

- Se define la función `imprimirSerieAlternada` que toma un parámetro `n` (el valor más alto de la serie).

- Se inicializa un arreglo `serie` que contendrá los números de la serie.

- Se utiliza un bucle `for` que itera desde 1 hasta `(n + 1) / 2`. Dentro del bucle, se agrega el valor actual `i` al arreglo `serie`. Luego, se verifica si `i` no es igual a `n - i + 1` (para asegurarse de que no se dupliquen los números en caso de que `n` sea impar), y si es así, se agrega `n - i + 1` al arreglo `serie`.

- Se convierte el arreglo `serie` en una cadena de texto `serieString` utilizando `map` y `joined`, separando los números con espacios.

- Se utiliza la función `print` para mostrar la serie generada en la consola.

### Resultados Obtenidos:
El código genera y muestra la serie alternada de números en la consola.

### Sentencias Completas:

```swift
import Foundation

func imprimirSerieAlternada(_ n: Int) {
    var serie = [Int]()
    
    for i in 1...(n + 1) / 2 {
        serie.append(i)
        if i != n - i + 1 {
            serie.append(n - i + 1)
        }
    }
    
    let serieString = serie.map { String($0) }.joined(separator: " ")
    print(serieString)
}

imprimirSerieAlternada(4)
imprimirSerieAlternada(9)
```

### Consideraciones:
Este código asume que el valor de n proporcionado es válido.

---

## Imprimir un Árbol de Asteriscos en Swift

### Explicación Breve:
En este código, se define una función `imprimirArbolito` que imprime un patrón en forma de árbol utilizando asteriscos. El número de líneas del árbol se determina mediante el parámetro `nLineas`. El código utiliza dos bucles `for` para construir y mostrar el árbol.

### Pasos de la Realización:

- Se importa la librería Foundation para utilizar funciones de impresión y otras utilidades.

- Se define la función `imprimirArbolito` que toma un parámetro `nLineas` (el número de líneas del árbol).

- Se utiliza un bucle `for` que itera desde 1 hasta `nLineas`. En cada iteración, se calcula la cantidad de asteriscos que se deben mostrar en esa línea, que es igual a `item * 2 - 1`, donde `item` es el número de la línea actual.

- Se inicializa una cadena de caracteres vacía llamada `asteriscos` para construir la línea actual del árbol.

- Se utiliza otro bucle `for` que itera desde 1 hasta `cantidadMostrar`, donde `cantidadMostrar` es la cantidad de asteriscos que se deben mostrar en la línea actual. En cada iteración de este bucle, se agrega un asterisco (`*`) a la cadena `asteriscos`.

- Antes de agregar el primer asterisco, se verifica si es la primera línea (`item2 == 1`) y si solo hay un asterisco en esa línea (`cantidadMostrar == 1`). En ese caso, se agrega un espacio antes y después del asterisco para centrarlo.

- Se utiliza la función `print` para mostrar la línea actual del árbol.

- El bucle principal se encarga de construir y mostrar todas las líneas del árbol.

### Resultados Obtenidos:
El código genera y muestra un patrón en forma de árbol de asteriscos en la consola, con el número de líneas especificado por `nLineas`.

### Sentencias Completas:

```swift
import Foundation

func imprimirArbolito(_ nLineas: Int) {
    for item in 1...nLineas {
        let cantidadMostrar = item * 2 - 1
        var asteriscos = ""
        for item2 in 1...cantidadMostrar {
            if item2 == 1 && cantidadMostrar == 1 {
                asteriscos.append(" " + "*" +  " ")
            } else {
                asteriscos.append("*")
            }
        }
        print(asteriscos)
    }
}

let n = 4

imprimirArbolito(n)
```

### Consideraciones:
Este código asume que el valor de nLineas proporcionado es válido y mayor que cero.

---

## Generar una Serie de Fibonacci en Swift

### Explicación Breve:
En este código, se genera una serie de Fibonacci con una longitud de `nNumero` términos. La serie comienza con los dos primeros números (1 y 1) y luego se calculan los números siguientes sumando los dos anteriores. El resultado se almacena en el arreglo `salida`.

### Pasos de la Realización:

- Se importa la librería Foundation para utilizar funciones de impresión y otras utilidades.

- Se inicializa la variable `nNumero` con el valor 10, que representa la cantidad de términos de la serie de Fibonacci que se generarán.

- Se crea un arreglo `salida` con los dos primeros números de la serie de Fibonacci (1 y 1).

- Se utiliza un bucle `for` que itera desde 0 hasta `nNumero - 1`. En cada iteración del bucle, se verifica si `number` es mayor o igual a 2 (para evitar calcular los dos primeros números nuevamente).

- Si `number` es mayor o igual a 2, se calcula el siguiente número de Fibonacci sumando los dos números anteriores (`a` y `b`) y se agrega al arreglo `salida`.

- Finalmente, se imprime el arreglo `salida`, que contiene la serie de Fibonacci generada.

### Resultados Obtenidos:
El código genera y muestra una serie de Fibonacci con una longitud de `nNumero` términos en la consola.

### Sentencias Completas:

```swift
import Foundation

let nNumero = 10
var salida = [1, 1]

for number in 0..<nNumero {
    if number >= 2 {
        let a = salida[number - 2]
        let b = salida[number - 1]
        let suma = a + b
        salida.append(suma)
    }
}

print(salida)
```

### Consideraciones:
Este código asume que el valor de nNumero proporcionado es válido y mayor que cero.

---

## Verificar si un Número es Primo en Swift

### Explicación Breve:
En este código, se define una función `isPrime` que verifica si un número entero `n` es primo o no. Luego, se utiliza esta función para determinar si el número 15 es primo o no.

### Pasos de la Realización:

- Se importa la librería Foundation para utilizar funciones de impresión y otras utilidades.

- Se define la función `isPrime` que toma un parámetro `n` y verifica si es primo o no.

- Dentro de la función `isPrime`, se utilizan varios `guard` statements para manejar los casos especiales: números menores a 2 no son primos, el número 2 es primo, y los números pares (excepto el 2) no son primos.

- Luego, se utiliza `stride` para generar un rango de números impares desde 3 hasta la raíz cuadrada de `n`, y se verifica si alguno de esos números divide exactamente a `n`. Si se encuentra un divisor, la función retorna `false`, lo que indica que `n` no es primo. Si no se encuentra ningún divisor, la función retorna `true`, indicando que `n` es primo.

- Finalmente, se utiliza la función `isPrime` para verificar si el número 15 es primo o no, y se muestra un mensaje en la consola en consecuencia.

### Resultados Obtenidos:
El código verifica si el número 15 es primo y muestra el resultado en la consola.

### Sentencias Completas:

```swift
import Foundation

var esPrimo = false

func isPrime(_ n: Int) -> Bool {
    guard n >= 2     else { return false }
    guard n != 2     else { return true  }
    guard n % 2 != 0 else { return false }
    return !stride(from: 3, through: Int(sqrt(Double(n))), by: 2).contains { n % $0 == 0 }
}

if isPrime(15) {
    print("Es primo")
} else {
    print("No es primo")
}
```

### Consideraciones:
Este código asume que el valor de n proporcionado es un número entero positivo.

---

## Rellenar con Ceros a la Izquierda en Swift

### Explicación Breve:
En este código, se define una función `pad` que toma una cadena `string` y un tamaño deseado `toSize` y rellena la cadena con ceros a la izquierda para que tenga la longitud especificada. Luego, se utiliza esta función para rellenar con ceros a la izquierda una representación binaria de un número.

### Pasos de la Realización:

- Se define la función `pad` que toma dos parámetros: `string` (la cadena que se va a rellenar) y `toSize` (la longitud deseada de la cadena final).

- Dentro de la función `pad`, se inicializa la variable `padded` con el valor de `string`.

- Se utiliza un bucle `for` para iterar desde 0 hasta la diferencia entre `toSize` y la longitud actual de `string`. En cada iteración, se agrega un cero a la izquierda a la cadena `padded`.

- Finalmente, se retorna la cadena `padded` con ceros añadidos a la izquierda.

- Se declara la variable `num` con el valor 78.

- Se convierte el número `num` a su representación binaria como una cadena de texto utilizando `String(num, radix: 2)`.

- Se utiliza la función `print` para mostrar la representación binaria de `num` en la consola.

- Se utiliza la función `pad` para rellenar con ceros a la izquierda la representación binaria de `num` para que tenga una longitud de 8 caracteres.

### Resultados Obtenidos:
El código convierte el número 78 a su representación binaria y luego rellena con ceros a la izquierda para que tenga una longitud de 8 caracteres. Los resultados se muestran en la consola.

### Sentencias Completas:

```swift
func pad(string: String, toSize: Int) -> String {
    var padded = string
    for _ in 0..<(toSize - string.count) {
        padded = "0" + padded
    }
    return padded
}

let num = 78
let str = String(num, radix: 2)
print(str)
let paddedStr = pad(string: str, toSize: 8)
print(paddedStr)
```

### Consideraciones:
Este código asume que el valor de toSize proporcionado es mayor o igual que la longitud actual de string.

---

## Encontrar el Número Mayor en un Array en Swift

### Explicación Breve:
En este código, se busca el número mayor en un arreglo (`arrayNumeros`) de enteros en Swift. El código utiliza un bucle `for` para iterar a través del arreglo y realizar un seguimiento del número mayor encontrado hasta ese momento. Al final del bucle, se imprime el número mayor.

### Pasos de la Realización:

- Se define un arreglo `arrayNumeros` que contiene los números `[1, 2, 3, 10, 100]`.

- Se inicializan las variables `majorNumber` y `previewNumber` con el valor 0. `majorNumber` se utiliza para almacenar el número mayor encontrado hasta el momento, y `previewNumber` se utiliza para almacenar el número anterior en la iteración.

- Se utiliza un bucle `for` para iterar a través de los elementos del arreglo `arrayNumeros`. En cada iteración, se compara el número actual (`currentNumber`) con el número anterior (`previewNumber`).

- Si `currentNumber` es mayor que `previewNumber`, se actualiza `majorNumber` con el valor de `currentNumber` y se actualiza `previewNumber` con el mismo valor.

- Si `currentNumber` no es mayor que `previewNumber`, se actualiza solo `previewNumber` con el valor de `currentNumber`.

- Al final del bucle, `majorNumber` contendrá el número mayor encontrado en el arreglo.

- Se utiliza la función `print` para mostrar el número mayor en la consola.

### Resultados Obtenidos:
El código encuentra el número mayor en el arreglo `arrayNumeros` y lo muestra en la consola.

### Sentencias Completas:

```swift
let arrayNumeros = [1, 2, 3, 10, 100]
var majorNumber = 0
var previewNumber = 0

for numero in arrayNumeros {
    var currentNumber = numero
    if currentNumber > previewNumber {
        majorNumber = currentNumber
        previewNumber = currentNumber
    } else {
        previewNumber = currentNumber
    }
}

print(majorNumber)
```

### Consideraciones:
Este código asume que el arreglo arrayNumeros contiene al menos un elemento.

---

## Reversar un Vector en Swift

### Explicación Breve:
En este código, se invierte el orden de un vector (o arreglo) en Swift. El código utiliza la función `reverse()` para realizar la inversión y luego muestra el vector invertido en la consola.

### Pasos de la Realización:

- Se define un vector `vector` que contiene los números `[1, 2, 3, 10, 100]`.

- Se utiliza la función `reverse()` para invertir el orden de los elementos en el vector `vector`. Esta función modifica el vector original y lo invierte.

- Finalmente, se utiliza la función `print` para mostrar el vector invertido en la consola.

### Resultados Obtenidos:
El código invierte el orden de los elementos en el vector `vector` y muestra el vector invertido en la consola.

### Sentencias Completas:

```swift
var vector = [1, 2, 3, 10, 100]
vector.reverse()
print(vector)
```

### Consideraciones:
Este código modifica el vector original al invertirlo.

---

## Encontrar Elementos Duplicados entre dos Arrays en Swift

### Explicación Breve:
En este código, se encuentran los elementos duplicados entre dos arreglos (`arrayA` y `arrayB`) en Swift. El código utiliza dos bucles `for` anidados para comparar cada elemento de `arrayB` con cada elemento de `arrayA`. Si encuentra un elemento que es igual en ambos arreglos, lo agrega al arreglo `arrayDuplicado`. Al final del proceso, `arrayDuplicado` contendrá los elementos duplicados.

### Pasos de la Realización:

- Se importa la librería Foundation para utilizar funciones de impresión y otras utilidades.

- Se definen dos arreglos, `arrayA` y `arrayB`, que contienen los números `[1, 2, 3, 10, 100]` y `[1, 2, 3, 4, 5, 6]`, respectivamente.

- Se inicializa un arreglo `arrayDuplicado` vacío para almacenar los elementos duplicados.

- Se utilizan dos bucles `for` anidados. El primer bucle itera a través de los elementos de `arrayB` (`itemA`) y el segundo bucle itera a través de los elementos de `arrayA` (`itemB`).

- En cada iteración, se compara `itemA` con `itemB`. Si son iguales, se agrega `itemB` al arreglo `arrayDuplicado`.

- Al final del proceso, `arrayDuplicado` contiene los elementos que se encontraron duplicados entre `arrayA` y `arrayB`.

- Se utiliza la función `print` para mostrar el contenido de `arrayDuplicado` en la consola.

### Resultados Obtenidos:
El código encuentra y muestra los elementos que están duplicados entre `arrayA` y `arrayB` en la consola.

### Sentencias Completas:

```swift
import Foundation

let arrayA = [1, 2, 3, 10, 100]
let arrayB = [1, 2, 3, 4, 5, 6]

var arrayDuplicado = [Int]()

for itemA in arrayB {
    for itemB in arrayA {
        if itemB == itemA {
            arrayDuplicado.append(itemB)
        }
    }
}

print(arrayDuplicado)
```

### Consideraciones:
Este código encuentra solo los elementos que están duplicados y los agrega una vez al arreglo arrayDuplicado, incluso si están duplicados más de una vez en ambos arreglos.

---

## Convertir una Cadena en un Array de Caracteres en Swift

### Explicación Breve:
En este código, se toma una cadena de texto (`cadena`) y se convierte en un arreglo de caracteres en Swift. Luego, se imprime el arreglo de caracteres en la consola.

### Pasos de la Realización:

- Se define una cadena de texto `cadena` con el valor `"12345"`.

- Se utiliza la función `Array()` para convertir la cadena `cadena` en un arreglo de caracteres `array`.

- Finalmente, se utiliza la función `print` para mostrar el arreglo de caracteres en la consola.

### Resultados Obtenidos:
El código convierte la cadena `"12345"` en un arreglo de caracteres y muestra el arreglo en la consola.

### Sentencias Completas:

```swift
var cadena = "12345"
var array = Array(cadena)
print(array)
```

### Consideraciones:
La función Array() se utiliza para convertir una cadena en un arreglo de caracteres en Swift.

---

## Sumar Matrices en Swift

### Explicación Breve:
En este código, se suman dos matrices bidimensionales (`arrayA` y `arrayB`) en Swift. El código utiliza bucles `for` anidados para recorrer ambas matrices y realizar la suma de los elementos correspondientes. El resultado se almacena en la matriz `arraySuma` y se muestra en la consola.

### Pasos de la Realización:

- Se importa la librería Foundation para utilizar funciones de impresión y otras utilidades.

- Se definen dos matrices bidimensionales, `arrayA` y `arrayB`, que contienen valores enteros.

- Se inicializa una matriz vacía `arraySuma` que se utilizará para almacenar el resultado de la suma.

- Se utiliza un bucle `for` para iterar a través de los índices de las filas de `arrayA` y `arrayB` (índice `itemIndex`).

- Dentro del primer bucle `for`, se inicializa un arreglo `arryToAdd` que se utilizará para almacenar la fila resultante de la suma.

- Se utiliza un segundo bucle `for` para iterar a través de los índices de las columnas de `arrayA` y `arrayB` (índice `itemIndexB`).

- En cada iteración de los bucles anidados, se suma el elemento correspondiente de `arrayA` y `arrayB`, y el resultado se agrega al arreglo `arryToAdd`.

- Una vez completada la suma de una fila, se agrega el arreglo `arryToAdd` a la matriz `arraySuma`.

- Al final del proceso, `arraySuma` contendrá la suma de las dos matrices.

- Se utiliza la función `print` para mostrar el contenido de `arraySuma` en la consola.

### Resultados Obtenidos:
El código suma las matrices `arrayA` y `arrayB` y muestra el resultado en la consola.

### Sentencias Completas:

```swift
import Foundation

let arrayA = [[2, 0, 1], [3, 0, 0], [5, 1, 1]]
let arrayB = [[1, 0, 1], [1, 2, 1], [1, 1, 0]]
var arraySuma = [[Int]]()

for itemIndex in 0..<arrayA.count {
    var arryToAdd = [Int]()
    for itemIndexB in 0..<arrayB.count {
        let suma = arrayA[itemIndex][itemIndexB] + arrayB[itemIndex][itemIndexB]
        arryToAdd.append(suma)
    }
    arraySuma.append(arryToAdd)
}

print(arraySuma)
```

### Consideraciones:
Este código asume que las matrices arrayA y arrayB tienen el mismo tamaño y contienen valores enteros.

---

## Restar Matrices en Swift

### Explicación Breve:
En este código, se restan dos matrices bidimensionales (`arrayA` y `arrayB`) en Swift. El código utiliza bucles `for` anidados para recorrer ambas matrices y realizar la resta de los elementos correspondientes. El resultado se almacena en la matriz `arraySuma` y se muestra en la consola.

### Pasos de la Realización:

- Se importa la librería Foundation para utilizar funciones de impresión y otras utilidades.

- Se definen dos matrices bidimensionales, `arrayA` y `arrayB`, que contienen valores enteros.

- Se inicializa una matriz vacía `arraySuma` que se utilizará para almacenar el resultado de la resta.

- Se utiliza un bucle `for` para iterar a través de los índices de las filas de `arrayA` y `arrayB` (índice `itemIndex`).

- Dentro del primer bucle `for`, se inicializa un arreglo `arryToAdd` que se utilizará para almacenar la fila resultante de la resta.

- Se utiliza un segundo bucle `for` para iterar a través de los índices de las columnas de `arrayA` y `arrayB` (índice `itemIndexB`).

- En cada iteración de los bucles anidados, se resta el elemento correspondiente de `arrayA` y `arrayB`, y el resultado se agrega al arreglo `arryToAdd`.

- Una vez completada la resta de una fila, se agrega el arreglo `arryToAdd` a la matriz `arraySuma`.

- Al final del proceso, `arraySuma` contendrá la resta de las dos matrices.

- Se utiliza la función `print` para mostrar el contenido de `arraySuma` en la consola.

### Resultados Obtenidos:
El código resta las matrices `arrayA` y `arrayB` y muestra el resultado en la consola.

### Sentencias Completas:

```swift
import Foundation

let arrayA = [[2, 0, 1], [3, 0, 0], [5, 1, 1]]
let arrayB = [[1, 0, 1], [1, 2, 1], [1, 1, 0]]
var arraySuma = [[Int]]()

for itemIndex in 0..<arrayA.count {
    var arryToAdd = [Int]()
    for itemIndexB in 0..<arrayB.count {
        let resta = arrayA[itemIndex][itemIndexB] - arrayB[itemIndex][itemIndexB]
        arryToAdd.append(resta)
    }
    arraySuma.append(arryToAdd)
}

print(arraySuma)
```

### Consideraciones:
Este código asume que las matrices arrayA y arrayB tienen el mismo tamaño y contienen valores enteros.

---

## Extraer Diagonales de una Matriz Cuadrada en Swift

### Explicación Breve:
En este código, se extraen las diagonales de una matriz cuadrada en Swift. Se definen dos arreglos, `DP` para la diagonal principal y `DI` para la diagonal inversa. Luego, se recorre la matriz y se agregan los elementos correspondientes a estas diagonales. Los resultados se muestran en la consola.

### Pasos de la Realización:

- Se define una función `extractDiagonals` que toma como entrada una matriz bidimensional `matrix` de tipo entero y devuelve una tupla con dos arreglos, `DP` para la diagonal principal y `DI` para la diagonal inversa.

- Se obtiene el tamaño `n` de la matriz cuadrada `matrix` tomando la longitud de una de sus filas.

- Se inicializan dos arreglos vacíos, `DP` y `DI`, para almacenar los elementos de las diagonales principal e inversa, respectivamente.

- Se utilizan dos bucles `for` anidados para recorrer la matriz. En cada iteración, se verifica si el índice `i` es igual al índice `j`, lo que indica que el elemento pertenece a la diagonal principal, y se agrega a `DP`. Además, se verifica si la suma de `i` y `j` es igual a `n - 1`, lo que indica que el elemento pertenece a la diagonal inversa, y se agrega a `DI`.

- Al final del proceso, la función devuelve la tupla con los arreglos `DP` y `DI`.

- Se define una matriz cuadrada `matrizCuadrada` de ejemplo.

- Se llama a la función `extractDiagonals` pasando `matrizCuadrada` como argumento y se almacena el resultado en la variable `diagonales`.

- Se utiliza la función `print` para mostrar las diagonales principal e inversa en la consola.

### Resultados Obtenidos:
El código extrae las diagonales principal e inversa de la matriz cuadrada de ejemplo `matrizCuadrada` y las muestra en la consola.

### Sentencias Completas:

```swift
import Foundation

func extractDiagonals(matrix: [[Int]]) -> (DP: [Int], DI: [Int]) {
    let n = matrix.count
    var DP = [Int]()
    var DI = [Int]()
    
    for i in 0..<n {
        for j in 0..<n {
            if i == j {
                DP.append(matrix[i][j])
            }
            if i + j == n - 1 {
                DI.append(matrix[i][j])
            }
        }
    }
    
    return (DP, DI)
}

let matrizCuadrada = [
    [3, 5, 8, 2],
    [2, 7, 9, 5],
    [2, 8, 9, 2],
    [4, 6, 7, 1]
]

let diagonales = extractDiagonals(matrix: matrizCuadrada)
print("Diagonal Principal: \(diagonales.DP)")
print("Diagonal Inversa: \(diagonales.DI)")
```

### Consideraciones:
Este código asume que la matriz de entrada es cuadrada, es decir, tiene el mismo número de filas y columnas.

---

## Suma de Elementos Internos de una Matriz en Swift

### Explicación Breve:
En este código, se calcula la suma de los elementos internos de una matriz cuadrada en Swift. Se define una función `sumInnerElements` que toma como entrada una matriz bidimensional `matrix` de tipo entero y devuelve la suma de los elementos que se encuentran en el interior de la matriz (excluyendo los elementos en el borde). El resultado se muestra en la consola.

### Pasos de la Realización:

- Se importa la librería Foundation para utilizar funciones de impresión y otras utilidades.

- Se define una función `sumInnerElements` que toma como entrada una matriz bidimensional `matrix` de tipo entero y devuelve la suma de los elementos que se encuentran en el interior de la matriz (excluyendo los elementos en el borde).

- Se obtiene el tamaño `n` de la matriz cuadrada `matrix` tomando la longitud de una de sus filas.

- Se inicializa una variable `sum` para almacenar la suma de los elementos internos.

- Se utilizan dos bucles `for` anidados para recorrer la matriz desde la segunda fila hasta la penúltima fila y desde la segunda columna hasta la penúltima columna. En cada iteración, se agrega el elemento correspondiente a la variable `sum`.

- Al final del proceso, la función devuelve la suma `sum`.

- Se define una matriz cuadrada `matrizCuadrada` de ejemplo.

- Se llama a la función `sumInnerElements` pasando `matrizCuadrada` como argumento y se almacena el resultado en la variable `resultado`.

- Se utiliza la función `print` para mostrar la suma de los elementos internos en la consola.

### Resultados Obtenidos:
El código calcula la suma de los elementos internos de la matriz cuadrada de ejemplo `matrizCuadrada` y muestra el resultado en la consola.

### Sentencias Completas:

```swift
import Foundation

func sumInnerElements(matrix: [[Int]]) -> Int {
    let n = matrix.count
    var sum = 0
    
    for i in 1..<n-1 {
        for j in 1..<n-1 {
            sum += matrix[i][j]
        }
    }
    
    return sum
}

let matrizCuadrada = [
    [3, 5, 8, 9, 2],
    [1, 4, 2, 1, 0],
    [4, 5, 4, 8, 1],
    [9, 8, 1, 0, 3],
    [7, 2, 1, 1, 3]
]

let resultado = sumInnerElements(matrix: matrizCuadrada)
print("La suma de los elementos internos es: \(resultado)")
```

### Consideraciones:
* Este código asume que la matriz de entrada es cuadrada, es decir, tiene el mismo número de filas y columnas.
* La suma de los elementos internos excluye los elementos en el borde de la matriz.

---

## Función para Determinar el Mayor de Dos Números en Swift

### Explicación Breve:
En este código, se define una función `isMayor` en Swift que toma dos números enteros como argumentos y devuelve el mayor de los dos números. La función utiliza una estructura condicional para comparar los números y determinar cuál es mayor.

### Pasos de la Realización:

- Se define una función `isMayor` que toma dos parámetros de entrada, `a` y `b`, ambos de tipo entero.

- Dentro de la función, se utiliza una estructura condicional `if-else` para comparar `a` y `b`. Si `a` es mayor que `b`, se devuelve `a`, de lo contrario, se devuelve `b`.

- La función devuelve un valor entero, que es el mayor de los dos números.

- Se llama a la función `isMayor` con diferentes pares de números como argumentos y se utiliza la función `print` para mostrar el resultado en la consola.

### Resultados Obtenidos:
El código determina el mayor de dos números utilizando la función `isMayor` y muestra los resultados en la consola.

### Sentencias Completas:

```swift
func isMayor(_ a: Int, _ b: Int) -> Int {
    if a > b {
        return a
    } else {
        return b
    }
}

print(isMayor(2, 5))
print(isMayor(8, 2))
```

### Consideraciones:
Este código es una implementación simple para determinar el mayor de dos números y se puede utilizar en situaciones donde se necesite esta comparación.

---

## Función para Crear un Arreglo de Enteros en Swift

### Explicación Breve:
En este código, se define una función `isMayor` en Swift que toma un número entero como argumento y devuelve un arreglo que contiene una secuencia de números desde 1 hasta el número recibido. La función utiliza un bucle `for` para construir el arreglo y lo devuelve como resultado.

### Pasos de la Realización:

- Se define un arreglo `arrayToResponse` que se utilizará para almacenar los números generados por la función.

- Se define una función `isMayor` que toma un parámetro de entrada `numberRecived` de tipo entero.

- Dentro de la función, se utiliza un bucle `for` para iterar desde 1 hasta el número recibido (`numberRecived`). En cada iteración, se agrega el número actual al arreglo `arrayToResponse`.

- La función devuelve el arreglo `arrayToResponse` como resultado.

- Se llama a la función `isMayor` con diferentes valores como argumentos y se utiliza la función `print` para mostrar el arreglo resultante en la consola.

### Resultados Obtenidos:
El código genera arreglos que contienen secuencias de números desde 1 hasta el número recibido como argumento de la función `isMayor`.

### Sentencias Completas:

```swift
var arrayToResponse = [Int]()

func isMayor(numberRecived: Int) -> [Int] {
    for number in 1...numberRecived {
        arrayToResponse.append(number)
    }
    return arrayToResponse
}

print(isMayor(numberRecived: 8))
arrayToResponse.removeAll()
print(isMayor(numberRecived: 3))
```

### Consideraciones:
* Este código muestra cómo crear un arreglo de números enteros en una secuencia ascendente a partir de un número dado.
* El arreglo arrayToResponse se reinicia (se eliminan todos sus elementos) antes de cada llamada a la función para asegurarse de que esté vacío antes de agregar nuevos elementos.

---

## Cálculo de Minutos Transcurridos entre Dos Horas en Swift

### Explicación Breve:
En este código, se define una función `calcularMinutosTranscurridos` en Swift que calcula la cantidad de minutos transcurridos entre dos horas especificadas. La función toma las horas iniciales y finales, así como los minutos iniciales y finales (opcionalmente), y devuelve la cantidad de minutos transcurridos.

### Pasos de la Realización:

- Se importa la librería Foundation para utilizar funciones y tipos de datos adicionales.

- Se define una función `calcularMinutosTranscurridos` que toma los siguientes parámetros: `horaInicial` (hora de inicio), `minutosIniciales` (minutos de inicio, valor por defecto 0), `horaFinal` (hora de finalización) y `minutosFinales` (minutos de finalización, valor por defecto 0).

- Dentro de la función, se calcula el total de minutos correspondientes a la `horaInicial` y los `minutosIniciales` multiplicando la hora por 60 y sumando los minutos.

- De manera similar, se calcula el total de minutos para la `horaFinal` y los `minutosFinales`.

- Luego, se resta el total de minutos iniciales del total de minutos finales para obtener la cantidad de minutos transcurridos.

- La función devuelve la cantidad de minutos transcurridos como resultado.

- Se llaman a la función `calcularMinutosTranscurridos` con diferentes combinaciones de horas y minutos iniciales y finales, y se utiliza la función `print` para mostrar la cantidad de minutos transcurridos en la consola.

### Resultados Obtenidos:
El código calcula la cantidad de minutos transcurridos entre dos horas especificadas utilizando la función `calcularMinutosTranscurridos` y muestra los resultados en la consola.

### Sentencias Completas:

```swift
import Foundation

func calcularMinutosTranscurridos(horaInicial: Int, minutosIniciales: Int = 0, horaFinal: Int, minutosFinales: Int = 0) -> Int {
    let minutosInicialTotal = horaInicial * 60 + minutosIniciales
    let minutosFinalTotal = horaFinal * 60 + minutosFinales
    
    let minutosTranscurridos = minutosFinalTotal - minutosInicialTotal
    
    return minutosTranscurridos
}

let minutos1 = calcularMinutosTranscurridos(horaInicial: 12, minutosIniciales: 3, horaFinal: 13, minutosFinales: 10)
let minutos2 = calcularMinutosTranscurridos(horaInicial: 8, minutosIniciales: 10, horaFinal: 17, minutosFinales: 30)

print("Minutos transcurridos: \(minutos1)")
print("Minutos transcurridos: \(minutos2)")
```

### Consideraciones:
* La función calcularMinutosTranscurridos permite calcular los minutos transcurridos entre dos momentos en el día, incluyendo la posibilidad de especificar los minutos iniciales y finales de manera opcional.
* Los valores por defecto para los minutos iniciales y finales son 0.

---

## Implementación de una Pila Genérica en Swift

### Explicación Breve:
En este código, se define una estructura genérica llamada `Pila` en Swift que representa una pila (stack). La estructura `Pila` permite agregar elementos, obtener el valor del primer elemento y entregar y eliminar el primer elemento de la pila. Los elementos se almacenan en un arreglo privado.

### Pasos de la Realización:

- Se define una estructura `Pila` genérica que toma un tipo genérico `T` como parámetro. Esto permite que la pila pueda contener elementos de cualquier tipo.

- Dentro de la estructura `Pila`, se declara una propiedad privada `elementos` que es un arreglo de elementos de tipo `T`.

- Se define un método `agregar` que permite agregar un elemento de tipo `T` a la pila. El elemento se inserta en la parte superior de la pila (en la posición 0 del arreglo).

- Se define un método `obtenerValorDelPrimerElemento` que devuelve el valor del primer elemento de la pila sin eliminarlo. Este método retorna un valor opcional de tipo `T` que puede ser nulo si la pila está vacía.

- Se define un método `entregarYRemoverPrimerElemento` que entrega y elimina el primer elemento de la pila. Si la pila está vacía, este método retorna un valor nulo.

- Se crea una instancia `miPila` de tipo `Pila` que almacena valores enteros.

- Se agregan elementos a la pila utilizando el método `agregar`.

- Se utiliza el método `obtenerValorDelPrimerElemento` para obtener el valor del primer elemento de la pila y se muestra en la consola.

- Se utiliza el método `entregarYRemoverPrimerElemento` para entregar y eliminar el primer elemento de la pila y se muestra en la consola.

- Se utiliza nuevamente el método `obtenerValorDelPrimerElemento` para obtener el nuevo primer elemento de la pila después de la remoción.

### Resultados Obtenidos:
El código implementa una pila genérica en Swift y muestra cómo agregar elementos, obtener el valor del primer elemento y entregar y eliminar el primer elemento de la pila.

### Sentencias Completas:

```swift
import Foundation

struct Pila<T> {
    private var elementos = [T]()

    mutating func agregar(_ elemento: T) {
        elementos.insert(elemento, at: 0)
    }

    func obtenerValorDelPrimerElemento() -> T? {
        return elementos.first
    }

    mutating func entregarYRemoverPrimerElemento() -> T? {
        if elementos.isEmpty {
            return nil
        } else {
            return elementos.removeFirst()
        }
    }
}

var miPila = Pila<Int>()

miPila.agregar(5)
miPila.agregar(10)

if let primerElemento = miPila.obtenerValorDelPrimerElemento() {
    print("Valor del primer elemento: \(primerElemento)")
}

if let elementoRemovido = miPila.entregarYRemoverPrimerElemento() {
    print("Elemento removido: \(elementoRemovido)")
}

if let nuevoPrimerElemento = miPila.obtenerValorDelPrimerElemento() {
    print("Nuevo primer elemento: \(nuevoPrimerElemento)")
}
```

### Consideraciones:
* La estructura Pila es genérica, lo que significa que puede ser utilizada para almacenar elementos de cualquier tipo.
* Los métodos obtenerValorDelPrimerElemento y entregarYRemoverPrimerElemento devuelven valores opcionales (T?) para manejar casos en los que la pila está vacía.

---

## Implementación de una Cola Genérica en Swift

### Explicación Breve:
En este código, se define una estructura genérica llamada `Cola` en Swift que representa una cola (queue). La estructura `Cola` permite agregar elementos y entregar y eliminar el primer elemento de la cola. Los elementos se almacenan en un arreglo privado.

### Pasos de la Realización:

- Se define una estructura `Cola` genérica que toma un tipo genérico `T` como parámetro. Esto permite que la cola pueda contener elementos de cualquier tipo.

- Dentro de la estructura `Cola`, se declara una propiedad privada `elementos` que es un arreglo de elementos de tipo `T`.

- Se define un método `agregar` que permite agregar un elemento de tipo `T` a la cola. El elemento se agrega al final de la cola (al final del arreglo).

- Se define un método `entregarYRemoverPrimerElemento` que entrega y elimina el primer elemento de la cola. Si la cola está vacía, este método retorna un valor nulo.

- Se crea una instancia `miCola` de tipo `Cola` que almacena valores de tipo cadena (String).

- Se agregan elementos a la cola utilizando el método `agregar`.

- Se utiliza el método `entregarYRemoverPrimerElemento` para entregar y eliminar el primer elemento de la cola y se muestra en la consola.

- Se utiliza nuevamente el método `entregarYRemoverPrimerElemento` para obtener y eliminar el nuevo primer elemento de la cola después de la remoción.

### Resultados Obtenidos:
El código implementa una cola genérica en Swift y muestra cómo agregar elementos y entregar y eliminar el primer elemento de la cola.

### Sentencias Completas:

```swift
import Foundation

struct Cola<T> {
    private var elementos = [T]()

    mutating func agregar(_ elemento: T) {
        elementos.append(elemento)
    }

    mutating func entregarYRemoverPrimerElemento() -> T? {
        if elementos.isEmpty {
            return nil // La cola está vacía
        } else {
            return elementos.removeFirst()
        }
    }
}

var miCola = Cola<String>()

miCola.agregar("Manzana")
miCola.agregar("Plátano")

if let primerElemento = miCola.entregarYRemoverPrimerElemento() {
    print("Elemento removido: \(primerElemento)")
}

if let nuevoPrimerElemento = miCola.entregarYRemoverPrimerElemento() {
    print("Nuevo primer elemento: \(nuevoPrimerElemento)")
}
```

### Consideraciones:
* La estructura Cola es genérica, lo que significa que puede ser utilizada para almacenar elementos de cualquier tipo.
* El método entregarYRemoverPrimerElemento devuelve un valor opcional (T?) para manejar casos en los que la cola está vacía.

---

## Cálculo del Factorial en Swift

### Explicación Breve:
En este código, se calcula el factorial de un número dado en Swift. El factorial de un número entero positivo `n` se define como el producto de todos los números enteros positivos desde 1 hasta `n`.

### Pasos de la Realización:

- Se define una función `factorial` que toma un parámetro `numero` de tipo entero. Esta función calculará el factorial de ese número.

- Dentro de la función, se inicializa una variable `sumaFactorial` con el valor inicial de 1. Esta variable se utilizará para acumular el resultado del factorial.

- Se utiliza un bucle `for` que itera desde 1 hasta `numero`. En cada iteración, se multiplica `sumaFactorial` por el valor actual del bucle para calcular el factorial.

- Finalmente, se muestra el resultado del cálculo factorial en la consola.

### Resultados Obtenidos:
El código calcula el factorial del número 3 y muestra el resultado en la consola.

### Sentencias Completas:

```swift
import Foundation

func factorial(_ numero: Int) {
    var sumaFactorial = 1
    for number in 1...numero {
        sumaFactorial *= number
    }
    print(sumaFactorial)
}

factorial(3)
```

### Consideraciones:
* El código actual calcula el factorial de un número entero positivo. Asegúrate de proporcionar un valor válido cuando llames a la función factorial.

---

## Encontrar el Máximo y Mínimo de Tres Números en Swift

### Explicación Breve:
En este código, se determina el número más alto y el número más bajo entre tres números enteros en Swift.

### Pasos de la Realización:

- Se define una función `maximoNumero` que toma tres parámetros de entrada `a`, `b`, y `c`, que representan los tres números que se deben comparar.

- Dentro de la función, se utilizan varias estructuras condicionales `if` y `else if` para comparar los números y encontrar el número más alto y el número más bajo.

- Se comparan los números en grupos de dos para determinar cuál es el más alto y cuál es el más bajo en cada caso.

- Se muestran los resultados en la consola, indicando cuál es el número más alto y cuál es el número más bajo.

### Resultados Obtenidos:
El código compara los números 2, 5 y 8 y muestra en la consola que el número más alto es 8 y el número más bajo es 2.

### Sentencias Completas:

```swift
import Foundation

func maximoNumero (_ a: Int, _ b: Int, _ c: Int) {
    if a > b && a > c {
        if b > c {
            print("Numero mas alto: ", a)
            print("Numero mas bajo: ", c)
        } else {
            print("Numero mas alto: ", a)
            print("Numero mas bajo: ", b)
        }
    } else if b > a && b > c {
        if a > c {
            print("Numero mas alto: ", b)
            print("Numero mas bajo: ", c)
        } else {
            print("Numero mas alto: ", b)
            print("Numero mas bajo: ", a)
        }
    } else if c > a && c > b {
        if a > b {
            print("Numero mas alto: ", c)
            print("Numero mas bajo: ", b)
        } else {
            print("Numero mas alto: ", c)
            print("Numero mas bajo: ", a)
        }
    }
}

maximoNumero(2, 5, 8)
```

### Consideraciones:
* Este código es específico para tres números. Asegúrate de proporcionar tres valores al llamar a la función maximoNumero.

---

## Cálculo de la Posición Final Después de Seguir Direcciones en Swift

### Explicación Breve:
En este código, se calcula la posición final después de seguir una serie de direcciones en un plano. Las direcciones pueden ser derecha, izquierda, arriba o abajo, y se representan mediante un enum en Swift.

### Pasos de la Realización:

- Se define un enum llamado `Direction` que representa las cuatro posibles direcciones: derecha, izquierda, arriba y abajo.

- Se define una función `calcularPosicionFinal` que toma un arreglo de direcciones `pasos` como entrada y calcula la posición final en el plano.

- Dentro de la función, se inicializan las variables `posicionX` y `posicionY` con valores iniciales de 0.

- Se utiliza un bucle `for-in` para iterar a través de cada dirección en el arreglo `pasos`. En cada iteración, se utiliza una estructura `switch` para actualizar las coordenadas `posicionX` y `posicionY` según la dirección.

- Finalmente, se devuelve la posición final como una tupla `(x, y)`.

### Resultados Obtenidos:
El código sigue una serie de direcciones (arriba, arriba, izquierda, abajo, izquierda) y calcula la posición final en el plano. El resultado se muestra en la consola.

### Sentencias Completas:

```swift
import Foundation

enum Direction {
    case derecha
    case izquierda
    case arriba
    case abajo
}

func calcularPosicionFinal(pasos: [Direction]) -> (x: Int, y: Int) {
    var posicionX = 0
    var posicionY = 0
    
    for paso in pasos {
        switch paso {
        case .derecha:
            posicionX += 1
        case .izquierda:
            posicionX -= 1
        case .arriba:
            posicionY += 1
        case .abajo:
            posicionY -= 1
        }
    }
    
    return (posicionX, posicionY)
}

let pasos = [Direction.arriba, Direction.arriba, Direction.izquierda, Direction.abajo, Direction.izquierda]
let posicionFinal = calcularPosicionFinal(pasos: pasos)

print("Posición final: (\(posicionFinal.x), \(posicionFinal.y))")
```

### Consideraciones:
* Este código es genérico y puede utilizarse para seguir cualquier serie de direcciones definidas en el enum Direction.

---

## Juego de Piedra, Papel o Tijera en Swift

### Explicación Breve:
En este código, se implementa el juego clásico de "Piedra, Papel o Tijera" en Swift. Dos jugadores eligen una de las tres opciones, y se determina el resultado del juego.

### Pasos de la Realización:

- Se definen dos enums: `Eleccion` para representar las opciones (piedra, papel, tijera) y `Resultado` para representar el resultado del juego (gana, pierde, empata).

- Se crea una función llamada `juego` que toma las elecciones de dos jugadores como entrada y devuelve el resultado del juego según las reglas del juego.

- Dentro de la función, se utilizan declaraciones `if` y comparaciones para determinar quién gana o si el juego termina en empate.

- Se realizan las comparaciones necesarias para cada caso posible de elección.

- Finalmente, se utiliza un bloque `switch` para imprimir el resultado del juego en la consola según el valor devuelto por la función `juego`.

### Resultados Obtenidos:
El código permite a dos jugadores realizar una elección (piedra, papel o tijera) y determina el resultado del juego, que puede ser una victoria para el jugador 1, una derrota o un empate.

### Sentencias Completas:

```swift
import Foundation

enum Eleccion {
    case piedra
    case papel
    case tijera
}

enum Resultado {
    case gana
    case pierde
    case empata
}

func juego(eleccionJugador1: Eleccion, eleccionJugador2: Eleccion) -> Resultado {
    if eleccionJugador1 == eleccionJugador2 {
        return .empata
    } else if (eleccionJugador1 == .piedra && eleccionJugador2 == .tijera) ||
              (eleccionJugador1 == .papel && eleccionJugador2 == .piedra) ||
              (eleccionJugador1 == .tijera && eleccionJugador2 == .papel) {
        return .gana
    } else {
        return .pierde
    }
}

let eleccionJugador1 = Eleccion.tijera
let eleccionJugador2 = Eleccion.tijera

let resultado = juego(eleccionJugador1: eleccionJugador1, eleccionJugador2: eleccionJugador2)

switch resultado {
case .gana:
    print("El jugador 1 gana.")
case .pierde:
    print("El jugador 1 pierde.")
case .empata:
    print("Es un empate.")
}
```

### Consideraciones:
* Este código se basa en las reglas tradicionales del juego de "Piedra, Papel o Tijera", donde la piedra vence a las tijeras, las tijeras vencen al papel y el papel vence a la piedra.

---

## Obtener Nombres Completos desde un Arreglo de Personas en Swift

### Explicación Breve:
En este código, se define una función llamada `obtenerNombresCompletos` que toma un arreglo de personas como entrada y devuelve un arreglo de sus nombres completos. Luego, se utiliza esta función para obtener los nombres completos de las personas en el arreglo `personas`.

### Pasos de la Realización:

- Se define un arreglo de diccionarios llamado `personas`, donde cada diccionario representa a una persona con las claves "apellido" y "nombre".

- Se crea una función llamada `obtenerNombresCompletos` que toma como parámetro un arreglo de diccionarios `[String: String]` que representa a las personas.

- Dentro de la función, se inicializa un arreglo vacío llamado `nombresCompletos` para almacenar los nombres completos.

- Se itera a través de cada diccionario en el arreglo de personas.

- Para cada persona, se verifica si las claves "apellido" y "nombre" existen y son no nulas. Si ambas claves tienen valores válidos, se construye un nombre completo concatenando el nombre y el apellido y se agrega al arreglo `nombresCompletos`.

- Finalmente, la función devuelve el arreglo `nombresCompletos` que contiene los nombres completos de las personas.

- Se llama a la función `obtenerNombresCompletos` con el arreglo `personas` como argumento y se almacenan los nombres completos resultantes en la variable `nombresCompletos`.

- Se imprime cada nombre completo en la consola.

### Resultados Obtenidos:
El código permite obtener y mostrar los nombres completos de las personas a partir de un arreglo de diccionarios que contiene sus nombres y apellidos.

### Sentencias Completas:

```swift
import Foundation

let personas = [
    ["apellido": "Perea", "nombre": "Alicia"],
    ["apellido": "Flores", "nombre": "Norma"],
    ["apellido": "Noriega", "nombre": "Roberto"]
]

func obtenerNombresCompletos(from personas: [[String: String]]) -> [String] {
    var nombresCompletos = [String]()
    
    for persona in personas {
        if let apellido = persona["apellido"], let nombre = persona["nombre"] {
            let nombreCompleto = "\(nombre) \(apellido)"
            nombresCompletos.append(nombreCompleto)
        }
    }
    
    return nombresCompletos
}

let nombresCompletos = obtenerNombresCompletos(from: personas)

print("Nombres completos:")
for nombreCompleto in nombresCompletos {
    print(nombreCompleto)
}
```

### Consideraciones:
* El código utiliza un arreglo de diccionarios para representar a las personas y asume que cada diccionario tiene las claves "apellido" y "nombre". Si las claves fueran diferentes, el código debería ajustarse en consecuencia.
* Los nombres completos se construyen concatenando el nombre y el apellido con un espacio en blanco entre ellos. Si se necesitara un formato diferente, se podrían realizar ajustes en la construcción del nombre completo en la función obtenerNombresCompletos.

---

## Cálculo del MCD y Suma de Fracciones en Swift

### Explicación Breve:
En este código, se define una función llamada `calcularMCD` para calcular el MCD (Máximo Común Divisor) de dos números enteros. Luego, se implementa una función llamada `sumarFracciones` que toma dos fracciones representadas como tuplas `(numerador, denominador)` y devuelve su suma en forma de una nueva tupla de fracción simplificada.

### Pasos de la Realización:

#### Función `calcularMCD`:
- Se define una función `calcularMCD` que toma dos números enteros `a` y `b` como argumentos.
- Se calcula el valor absoluto de `a` y `b` utilizando la función `abs`.
- Se inicializa una variable `minVal` con el valor mínimo entre `absA` y `absB`.
- Se inicia un bucle `while` que continúa mientras `minVal` sea mayor que 0.
- Dentro del bucle, se verifica si `absA` es divisible por `minVal` y si `absB` es divisible por `minVal`. Si ambos son divisibles, se devuelve `minVal` como el MCD.
- Si no son divisibles, se decrementa `minVal` en 1 y se continúa el bucle.
- Si no se encuentra un MCD común, se devuelve 1 como valor predeterminado.

#### Función `sumarFracciones`:
- Se define una función `sumarFracciones` que toma dos tuplas `(numerador, denominador)` como fracciones `f1` y `f2`.
- Se descompone cada tupla en sus componentes: `numerador1`, `denominador1`, `numerador2` y `denominador2`.
- Se calcula el MCD de `denominador1` y `denominador2` utilizando la función `calcularMCD`.
- Se realiza una operación para obtener nuevos numeradores `nuevoNumerador1` y `nuevoNumerador2` que se utilizarán para sumar las fracciones.
- Se calcula el nuevo denominador `nuevoDenominador` que es el producto de los denominadores originales dividido por el MCD.
- Se suma `nuevoNumerador1` y `nuevoNumerador2` para obtener el numerador de la fracción resultante `sumaNumeradores`.

### Resultados Obtenidos:
El código permite calcular el MCD de dos números y luego suma dos fracciones representadas como tuplas `(numerador, denominador)`, devolviendo la fracción resultante en su forma simplificada.

### Sentencias Completas:

```swift
import Foundation

func calcularMCD(_ a: Int, _ b: Int) -> Int {
    let absA = abs(a)
    let absB = abs(b)
    var minVal = min(absA, absB)
    
    while minVal > 0 {
        if absA % minVal == 0 && absB % minVal == 0 {
            return minVal
        }
        minVal -= 1
    }
    
    return 1
}

func sumarFracciones(f1: (Int, Int), f2: (Int, Int)) -> (Int, Int) {
    let numerador1 = f1.0
    let denominador1 = f1.1
    let numerador2 = f2.0
    let denominador2 = f2.1
    
    let mcd = calcularMCD(denominador1, denominador2)
    
    let nuevoNumerador1 = numerador1 * (denominador2 / mcd)
    let nuevoNumerador2 = numerador2 * (denominador1 / mcd)
    
    let nuevoDenominador = denominador1 * (denominador2 / mcd)
    
    let sumaNumeradores = nuevoNumerador1 + nuevoNumerador2
    
    return (sumaNumeradores, nuevoDenominador)
}

let f1 = (5, 8)
let f2 = (17, 9)

let suma = sumarFracciones(f1: f1, f2: f2)
print("Suma de fracciones:", suma)
```

### Consideraciones:
* El código asume que las fracciones se representan como tuplas de la forma (numerador, denominador) y que los valores proporcionados son enteros.
* El MCD se utiliza para simplificar la fracción resultante.

---

